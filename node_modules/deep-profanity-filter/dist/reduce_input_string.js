"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconstructLocations = exports.reduceInputString = void 0;
/**
 * Reduce a string by removing any special characters that are not latin characters,
 * numbers or whitespace. Keep track of the segment start indices and lengths so that
 * we can reverse engineer where each segment really started in the original string.
 * @param inputString - The string that needs to be reduced by removing all special characters.
 * @returns The reduced string (with all special characters removed), as well as an array
 * of start indices and lengths that indicate where each part of the string really started
 * and ended in the original string.
 */
var reduceInputString = function (inputString) {
    var e_1, _a;
    var matches = inputString.matchAll(/[a-zA-Z0-9\s]+/g);
    var outString = '';
    var locationInfo = [];
    try {
        for (var matches_1 = __values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
            var match = matches_1_1.value;
            locationInfo.push({
                index: outString.length,
                offset: match.index - outString.length,
            });
            outString += match[0];
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return)) _a.call(matches_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        reducedInput: outString,
        reducedLocations: locationInfo,
    };
};
exports.reduceInputString = reduceInputString;
/**
 * Reconstructs the original "Location Information" of a bad word in a string that got
 * reduced and then matched against a regular expression. Uses the information that was
 * gathered when reducing the string (by removing all special characters except whitespace).
 * @param reducedInfos - Information generated by `reduceInputString` before matching the
 * reduced string against a regular expression.
 * @param matchInfo - Information on the matched words and locations, gotten when matching
 * the string from `reduceInputString` against a regular expression.
 * @returns BadWordMatchData with the locations and lengths of the matches projected back
 * onto the original, unreduced string.
 */
var reconstructLocations = function (reducedInfos, matchInfo) {
    var e_2, _a, e_3, _b;
    var newMatchInfo = [];
    try {
        for (var matchInfo_1 = __values(matchInfo), matchInfo_1_1 = matchInfo_1.next(); !matchInfo_1_1.done; matchInfo_1_1 = matchInfo_1.next()) {
            var match = matchInfo_1_1.value;
            var matchEndIndex = match.startIndex + match.length;
            var startOffset = 0;
            var endOffset = 0;
            try {
                for (var reducedInfos_1 = (e_3 = void 0, __values(reducedInfos)), reducedInfos_1_1 = reducedInfos_1.next(); !reducedInfos_1_1.done; reducedInfos_1_1 = reducedInfos_1.next()) {
                    var reducedInfo = reducedInfos_1_1.value;
                    if (reducedInfo.index <= match.startIndex) {
                        startOffset = reducedInfo.offset;
                        endOffset = reducedInfo.offset;
                    }
                    else if (reducedInfo.index < matchEndIndex) {
                        endOffset = reducedInfo.offset;
                    }
                    else {
                        break;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (reducedInfos_1_1 && !reducedInfos_1_1.done && (_b = reducedInfos_1.return)) _b.call(reducedInfos_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            newMatchInfo.push({
                word: match.word,
                startIndex: match.startIndex + startOffset,
                length: match.length + endOffset - startOffset,
            });
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (matchInfo_1_1 && !matchInfo_1_1.done && (_a = matchInfo_1.return)) _a.call(matchInfo_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return newMatchInfo;
};
exports.reconstructLocations = reconstructLocations;
//# sourceMappingURL=reduce_input_string.js.map