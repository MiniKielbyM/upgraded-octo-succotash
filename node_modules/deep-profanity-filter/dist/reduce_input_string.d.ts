import { BadWordMatchData } from './word_filter';
/**
 * The locations and lengths of segments in the string that were
 * uninterrupted by special characters.
 * This helps find the actual location of characters in the un-reduced string.
 */
type ReducedInputLocationInfo = {
    index: number;
    offset: number;
};
/**
 * Reduce a string by removing any special characters that are not latin characters,
 * numbers or whitespace. Keep track of the segment start indices and lengths so that
 * we can reverse engineer where each segment really started in the original string.
 * @param inputString - The string that needs to be reduced by removing all special characters.
 * @returns The reduced string (with all special characters removed), as well as an array
 * of start indices and lengths that indicate where each part of the string really started
 * and ended in the original string.
 */
export declare const reduceInputString: (inputString: string) => {
    reducedInput: string;
    reducedLocations: ReducedInputLocationInfo[];
};
/**
 * Reconstructs the original "Location Information" of a bad word in a string that got
 * reduced and then matched against a regular expression. Uses the information that was
 * gathered when reducing the string (by removing all special characters except whitespace).
 * @param reducedInfos - Information generated by `reduceInputString` before matching the
 * reduced string against a regular expression.
 * @param matchInfo - Information on the matched words and locations, gotten when matching
 * the string from `reduceInputString` against a regular expression.
 * @returns BadWordMatchData with the locations and lengths of the matches projected back
 * onto the original, unreduced string.
 */
export declare const reconstructLocations: (reducedInfos: ReducedInputLocationInfo[], matchInfo: BadWordMatchData[]) => BadWordMatchData[];
export {};
