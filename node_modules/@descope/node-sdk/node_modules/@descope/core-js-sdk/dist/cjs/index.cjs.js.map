{"version":3,"file":"index.cjs.js","sources":["../../src/constants/apiPaths.ts","../../src/constants/index.ts","../../src/httpClient/helpers/createFetchLogger.ts","../../src/httpClient/types.ts","../../src/httpClient/urlBuilder.ts","../../src/httpClient/utils.ts","../../src/httpClient/index.ts","../../src/constants/httpStatusCodes.ts","../../src/sdk/helpers/index.ts","../../src/sdk/validations/core.ts","../../src/sdk/validations/validators.ts","../../src/sdk/validations/index.ts","../../src/sdk/accesskey.ts","../../src/sdk/types.ts","../../src/sdk/enchantedLink/validations.ts","../../src/sdk/enchantedLink/index.ts","../../src/sdk/flow/index.ts","../../src/sdk/magicLink/validations.ts","../../src/sdk/magicLink/index.ts","../../src/sdk/oauth/types.ts","../../src/sdk/oauth/index.ts","../../src/sdk/otp/index.ts","../../src/sdk/saml.ts","../../src/sdk/totp.ts","../../src/sdk/password/validations.ts","../../src/sdk/password/index.ts","../../src/sdk/webauthn.ts","../../src/sdk/index.ts","../../src/createSdk.ts","../../src/index.ts","../../src/utils/wrapWith/index.ts"],"sourcesContent":["/** API paths for the Descope service APIs */\nexport default {\n  accessKey: {\n    exchange: '/v1/auth/accesskey/exchange',\n  },\n  otp: {\n    verify: '/v1/auth/otp/verify',\n    signIn: '/v1/auth/otp/signin',\n    signUp: '/v1/auth/otp/signup',\n    update: {\n      email: '/v1/auth/otp/update/email',\n      phone: '/v1/auth/otp/update/phone',\n    },\n    signUpOrIn: '/v1/auth/otp/signup-in',\n  },\n  magicLink: {\n    verify: '/v1/auth/magiclink/verify',\n    signIn: '/v1/auth/magiclink/signin',\n    signUp: '/v1/auth/magiclink/signup',\n    update: {\n      email: '/v1/auth/magiclink/update/email',\n      phone: '/v1/auth/magiclink/update/phone',\n    },\n    signUpOrIn: '/v1/auth/magiclink/signup-in',\n  },\n  enchantedLink: {\n    verify: '/v1/auth/enchantedlink/verify',\n    signIn: '/v1/auth/enchantedlink/signin',\n    signUp: '/v1/auth/enchantedlink/signup',\n    session: '/v1/auth/enchantedlink/pending-session',\n    update: {\n      email: '/v1/auth/enchantedlink/update/email',\n    },\n    signUpOrIn: '/v1/auth/enchantedlink/signup-in',\n  },\n  oauth: {\n    start: '/v1/auth/oauth/authorize',\n    exchange: '/v1/auth/oauth/exchange',\n  },\n  saml: {\n    start: '/v1/auth/saml/authorize',\n    exchange: '/v1/auth/saml/exchange',\n  },\n  totp: {\n    verify: '/v1/auth/totp/verify',\n    signUp: '/v1/auth/totp/signup',\n    update: '/v1/auth/totp/update',\n  },\n  webauthn: {\n    signUp: {\n      start: '/v1/auth/webauthn/signup/start',\n      finish: '/v1/auth/webauthn/signup/finish',\n    },\n    signIn: {\n      start: '/v1/auth/webauthn/signin/start',\n      finish: '/v1/auth/webauthn/signin/finish',\n    },\n    signUpOrIn: {\n      start: '/v1/auth/webauthn/signup-in/start',\n    },\n    update: {\n      start: 'v1/auth/webauthn/update/start',\n      finish: '/v1/auth/webauthn/update/finish',\n    },\n  },\n  password: {\n    signUp: '/v1/auth/password/signup',\n    signIn: '/v1/auth/password/signin',\n    sendReset: '/v1/auth/password/reset',\n    update: '/v1/auth/password/update',\n    replace: '/v1/auth/password/replace',\n    policy: '/v1/auth/password/policy',\n  },\n  refresh: '/v1/auth/refresh',\n  logout: '/v1/auth/logout',\n  logoutAll: '/v1/auth/logoutall',\n  me: '/v1/auth/me',\n  flow: {\n    start: '/v1/flow/start',\n    next: '/v1/flow/next',\n  },\n};\n","/** Default Descope API URL */\nexport const DEFAULT_BASE_API_URL = 'https://api.descope.com';\n\n/** Default magic link polling interval for checking if the user clicked on the magic link */\nexport const ENCHANTED_LINK_MIN_POLLING_INTERVAL_MS = 1000; // 1 second\n/** Default maximum time we are willing to wait for the magic link to be clicked */\nexport const ENCHANTED_LINK_MAX_POLLING_TIMEOUT_MS = 1000 * 60 * 10; // 10 minutes\n\n/** API paths to the Descope service */\nexport { default as apiPaths } from './apiPaths';\n","import { Logger } from '../../sdk/types';\nimport { Fetch } from '../types';\n\n/** Build a log message around HTTP calls  */\nconst httpLogBuilder = () => {\n  const msg: {\n    Title?: string;\n    Url?: string;\n    Method?: string;\n    Headers?: string;\n    Body?: string;\n    Status?: string;\n  } = {};\n\n  return {\n    headers(headers: HeadersInit) {\n      const headersObj =\n        typeof headers.entries === 'function'\n          ? Object.fromEntries(headers.entries())\n          : headers;\n      msg.Headers = JSON.stringify(headersObj);\n\n      return this;\n    },\n\n    body(body: string) {\n      msg.Body = body;\n      return this;\n    },\n\n    url(url: URL | string) {\n      msg.Url = url.toString();\n      return this;\n    },\n\n    method(method: string) {\n      msg.Method = method;\n      return this;\n    },\n\n    title(title: string) {\n      msg.Title = title;\n      return this;\n    },\n\n    status(status: string) {\n      msg.Status = status;\n      return this;\n    },\n\n    build() {\n      return Object.keys(msg)\n        .flatMap((key) =>\n          msg[key] ? [`${key !== 'Title' ? `${key}: ` : ''}${msg[key]}`] : []\n        )\n        .join('\\n');\n    },\n  };\n};\n\n/** Log the request object */\nconst buildRequestLog = (args: Parameters<Fetch>) =>\n  httpLogBuilder()\n    .title('Request')\n    .url(args[0])\n    .method(args[1].method)\n    .headers(args[1].headers)\n    .body(args[1].body)\n    .build();\n\n/** Log the response object */\nconst buildResponseLog = async (resp: Response) => {\n  const respBody = await resp.text();\n\n  return httpLogBuilder()\n    .title('Response')\n    .url(resp.url.toString())\n    .status(`${resp.status} ${resp.statusText}`)\n    .headers(resp.headers)\n    .body(respBody)\n    .build();\n};\n\nconst fetchWrapper =\n  (fetch: Fetch) =>\n  async (...args: Parameters<Fetch>) => {\n    const resp = await fetch(...args);\n\n    // we found out that cloning the response is problematic when using node fetch\n    // so instead, we are reading the body stream once and overriding the clone, text & json functions\n    const respText = await resp.text();\n\n    resp.text = () => Promise.resolve(respText);\n    resp.json = () => Promise.resolve(JSON.parse(respText));\n    resp.clone = () => resp;\n\n    return resp;\n  };\n\n/**\n * Create a fetch with a logger wrapped around it if a logger is given\n * @param logger Logger to send the logs to\n * @param receivedFetch Fetch to be used or built-in fetch if not provided\n *\n */\nconst createFetchLogger = (logger: Logger, receivedFetch?: Fetch) => {\n  const fetchInternal = fetchWrapper(receivedFetch || fetch);\n  if (!fetchInternal)\n    // eslint-disable-next-line no-console\n    logger?.warn(\n      'Fetch is not defined, you will not be able to send http requests, if you are running in a test, make sure fetch is defined globally'\n    );\n\n  if (!logger) return fetchInternal;\n  return async (...args: Parameters<Fetch>) => {\n    if (!fetchInternal)\n      throw Error(\n        'Cannot send http request, fetch is not defined, if you are running in a test, make sure fetch is defined globally'\n      );\n    logger.log(buildRequestLog(args));\n    const resp = await fetchInternal(...args);\n\n    logger[resp.ok ? 'log' : 'error'](await buildResponseLog(resp));\n\n    return resp;\n  };\n};\n\nexport default createFetchLogger;\n","import { Logger } from '../sdk/types';\n\n/** Request configuration including headers, query params and token */\ntype HttpClientReqConfig = {\n  headers?: HeadersInit;\n  queryParams?: { [key: string]: string };\n  token?: string;\n};\n\n/** HTTP methods we use in the client */\nexport enum HTTPMethods {\n  get = 'GET',\n  delete = 'DELETE',\n  post = 'POST',\n  put = 'PUT',\n}\n\n/** HTTP Client type that implements the HTTP method calls. Descopers can provide their own HTTP client although required only in rare cases. */\nexport type HttpClient = {\n  get: (path: string, config?: HttpClientReqConfig) => Promise<Response>;\n  post: (\n    path: string,\n    body?: any,\n    config?: HttpClientReqConfig\n  ) => Promise<Response>;\n  put: (\n    path: string,\n    body?: any,\n    config?: HttpClientReqConfig\n  ) => Promise<Response>;\n  delete: (path: string, config?: HttpClientReqConfig) => Promise<Response>;\n  hooks?: Hooks;\n};\n\nexport type Fetch = typeof fetch;\n\n/** Parameters for the HTTP client. Defaults should work for most cases. */\nexport type CreateHttpClientConfig = {\n  baseUrl: string;\n  projectId: string;\n  baseConfig?: { baseHeaders: HeadersInit };\n  logger?: Logger;\n  hooks?: Hooks;\n  cookiePolicy?: RequestCredentials;\n  fetch?: Fetch;\n};\n\n/** For before-request hook allows overriding parts of the request */\nexport type RequestConfig = {\n  path: string;\n  headers?: HeadersInit;\n  queryParams?: { [key: string]: string };\n  body?: any;\n  method: HTTPMethods;\n  token?: string;\n};\n\nexport type BeforeRequest = (config: RequestConfig) => RequestConfig;\nexport type AfterRequest = (\n  req: RequestConfig,\n  res: Response\n) => void | Promise<void>;\n\n/** Hooks before and after the request is made */\nexport type Hooks = {\n  beforeRequest?: BeforeRequest;\n  afterRequest?: AfterRequest;\n};\n","/** Build URL with given parts */\nexport const urlBuilder = ({\n  path,\n  baseUrl,\n  queryParams,\n}: {\n  path: string;\n  baseUrl: string;\n  queryParams: ConstructorParameters<typeof URLSearchParams>[0];\n}) => {\n  const url = new URL(path, baseUrl);\n  if (queryParams) url.search = new URLSearchParams(queryParams).toString();\n\n  return url;\n};\n","/* eslint-disable no-nested-ternary */\n\nconst getSrcArr = (source: HeadersInit) => {\n  if (Array.isArray(source)) return source;\n  if (source instanceof Headers) return Array.from(source.entries());\n  if (!source) return [];\n  return Object.entries(source);\n};\n\n/** Merge the given list of headers into a single Headers object */\nexport const mergeHeaders = (...sources: HeadersInit[]) =>\n  new Headers(\n    sources.reduce((acc: Record<string, string>, source) => {\n      const srcArr = getSrcArr(source);\n      srcArr.reduce((_, [key, value]) => {\n        acc[key] = value;\n\n        return acc;\n      }, acc);\n\n      return acc;\n    }, {})\n  );\n\n/** Serialize the body to JSON */\nexport const serializeBody = (body: Record<string, any>) =>\n  body === undefined ? undefined : JSON.stringify(body);\n","import createFetchLogger from './helpers/createFetchLogger';\nimport {\n  CreateHttpClientConfig,\n  HttpClient,\n  HTTPMethods,\n  RequestConfig,\n} from './types';\nimport { urlBuilder } from './urlBuilder';\nimport { mergeHeaders, serializeBody } from './utils';\n\n/**\n * Create a Bearer authorization header with concatenated projectId and token\n * @param projectId The project id to use in the header\n * @param token Token to be concatenated. Defaults to empty.\n */\nconst createAuthorizationHeader = (projectId: string, token = '') => {\n  let bearer = projectId;\n  if (token) {\n    bearer = bearer + ':' + token;\n  }\n  return {\n    Authorization: `Bearer ${bearer}`,\n  };\n};\n\ndeclare const BUILD_VERSION: string;\n\n/**\n * Create descope custom headers\n */\nconst createDescopeHeaders = () => {\n  return {\n    'x-descope-sdk-name': 'core-js',\n    'x-descope-sdk-version': BUILD_VERSION,\n  };\n};\n\n/**\n * Create the HTTP client used to send HTTP requests to the Descope API\n *\n * @param CreateHttpClientConfig Configuration for the client\n */\nconst createHttpClient = ({\n  baseUrl,\n  projectId,\n  baseConfig,\n  logger,\n  hooks,\n  cookiePolicy,\n  fetch,\n}: CreateHttpClientConfig): HttpClient => {\n  const fetchWithLogger = createFetchLogger(logger, fetch);\n\n  const sendRequest = async (config: RequestConfig) => {\n    const requestConfig = hooks?.beforeRequest\n      ? hooks.beforeRequest(config)\n      : config;\n\n    const { path, body, headers, queryParams, method, token } = requestConfig;\n\n    const res = await fetchWithLogger(\n      urlBuilder({ path, baseUrl, queryParams }),\n      {\n        headers: mergeHeaders(\n          createAuthorizationHeader(projectId, token),\n          createDescopeHeaders(),\n          baseConfig?.baseHeaders || {},\n          headers\n        ),\n        method,\n        body: serializeBody(body),\n        credentials: cookiePolicy || 'include',\n      }\n    );\n\n    if (hooks?.afterRequest) {\n      await hooks.afterRequest(config, res?.clone());\n    }\n\n    return res;\n  };\n\n  return {\n    get: (path: string, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body: undefined,\n        method: HTTPMethods.get,\n        token,\n      }),\n    post: (path, body, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body,\n        method: HTTPMethods.post,\n        token,\n      }),\n    put: (path, body, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body,\n        method: HTTPMethods.put,\n        token,\n      }),\n    delete: (path, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body: undefined,\n        method: HTTPMethods.delete,\n        token,\n      }),\n    hooks,\n  };\n};\n\nexport default createHttpClient;\nexport type { HttpClient };\n","export default {\n  TOO_MANY_REQUESTS: 429,\n};\n","import jwtDecode, { JwtPayload } from 'jwt-decode';\nimport { ResponseData, SdkResponse } from '../types';\nimport HttpStatusCodes from '../../constants/httpStatusCodes';\n\nfunction getJwtAuthorizationItems(\n  token: string,\n  tenant: string,\n  claim: string\n): string[] {\n  let claims: any = parseJwt(token);\n  if (tenant) {\n    claims = claims?.tenants?.[tenant];\n  }\n  const items = claims?.[claim];\n  return Array.isArray(items) ? items : [];\n}\n\nfunction parseJwt(token: string): JwtPayload {\n  if (typeof token !== 'string' || !token)\n    throw new Error('Invalid token provided');\n  return jwtDecode(token);\n}\n\n/**\n * Checks if the given JWT is still valid but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function isJwtExpired(token: string): boolean {\n  const { exp } = parseJwt(token);\n  const currentTime = new Date().getTime() / 1000;\n  return currentTime > exp;\n}\n\n/**\n * Returns the list of tenants in the given JWT\n *\n * @param token JWT token\n */\nexport function getTenants(token: string): string[] {\n  let claims: any = parseJwt(token);\n  const items = Object.keys(claims?.tenants);\n  return Array.isArray(items) ? items : [];\n}\n\n/**\n * Returns the list of permissions granted in the given JWT but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function getJwtPermissions(token: string, tenant?: string): string[] {\n  return getJwtAuthorizationItems(token, tenant, 'permissions');\n}\n\n/**\n * Returns the list of roles specified in the given JWT but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function getJwtRoles(token: string, tenant?: string): string[] {\n  return getJwtAuthorizationItems(token, tenant, 'roles');\n}\n\n/** Joins path parts making sure there is only one path separator between parts */\nexport const pathJoin = (...args: string[]) =>\n  args.join('/').replace(/\\/{2,}/g, '/');\n\n/** Transform the Promise Response to our internal SdkResponse implementation\n * @param response The Response promise from fetch\n * @param transform Optionally transform the response JSON to another type\n */\nexport async function transformResponse<\n  T extends ResponseData,\n  S extends ResponseData = T\n>(\n  response: Promise<Response>,\n  transform?: (data: T) => S\n): Promise<SdkResponse<S>> {\n  const resp = await response;\n\n  const ret: SdkResponse<S> = {\n    code: resp.status,\n    ok: resp.ok,\n    response: resp,\n  };\n\n  const data = await resp.clone().json();\n\n  if (!resp.ok) {\n    ret.error = data;\n\n    if (resp.status === HttpStatusCodes.TOO_MANY_REQUESTS) {\n      Object.assign(ret.error, {\n        retryAfter: Number.parseInt(resp.headers?.get('retry-after')) || 0,\n      });\n    }\n  } else if (transform) {\n    ret.data = transform(data);\n  } else {\n    ret.data = <S>data;\n  }\n\n  return ret;\n}\n","import { Validator, ValidationRule, MakeValidator } from './types';\n\nexport const createValidator =\n  (rule: ValidationRule, defaultMsg?: string): MakeValidator =>\n  (msg = defaultMsg) =>\n  (val) =>\n    !rule(val) ? msg.replace('{val}', val) : false;\n\nexport const createOrValidator =\n  (validators: Validator[], defaultMsg?: string): MakeValidator =>\n  (msg = defaultMsg) =>\n  (val) => {\n    const errors = validators.filter((validator) => validator(val));\n\n    if (errors.length < validators.length) return false;\n\n    return msg ? msg.replace('{val}', val) : errors.join(' OR ');\n  };\n\nexport const createValidation = (...validators: Validator[]) => ({\n  validate: (val: any) => {\n    validators.forEach((validator) => {\n      const errMsg = validator(val);\n      if (errMsg) throw new Error(errMsg);\n    });\n\n    return true;\n  },\n});\n","import get from 'lodash.get';\nimport { createOrValidator, createValidation, createValidator } from './core';\nimport { Validator } from './types';\n\nconst regexMatch = (regex: RegExp) => (val: any) => regex.test(val);\n\nconst validateString = (val: any) => typeof val === 'string';\n\nconst validateUndefined = (val: any) => val === undefined;\n\nconst validateEmail = regexMatch(\n  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/\n);\nconst validatePhone = regexMatch(/^\\+[1-9]{1}[0-9]{3,14}$/);\nconst validateMinLength = (min: number) => (val: any) => val.length >= min;\n// const validatePlainObject = (val: any) => !!val && Object.getPrototypeOf(val) === Object.prototype;\nconst validatePathValue = (path: string, rules: Validator[]) => (val: any) =>\n  createValidation(...rules).validate(get(val, path));\n\nexport const isEmail = createValidator(\n  validateEmail,\n  '\"{val}\" is not a valid email'\n);\nexport const isPhone = createValidator(\n  validatePhone,\n  '\"{val}\" is not a valid phone number'\n);\nexport const isNotEmpty = createValidator(\n  validateMinLength(1),\n  'Minimum length is 1'\n);\nexport const isString = createValidator(\n  validateString,\n  'Input is not a string'\n);\n\nexport const isUndefined = createValidator(\n  validateUndefined,\n  'Input is defined'\n);\n\nexport const isStringOrUndefined = createOrValidator(\n  [isString(), isUndefined()],\n  'Input is not a string or undefined'\n);\n\n// export const isPlainObject = createValidator(validatePlainObject, 'Input is not a plain object');\nexport const hasPathValue = (path: string, rules: Validator[]) =>\n  createValidator(validatePathValue(path, rules))();\n","import { createOrValidator, createValidation } from './core';\nimport { Validator } from './types';\nimport {\n  isEmail,\n  isNotEmpty,\n  isPhone,\n  isString,\n  isStringOrUndefined,\n} from './validators';\n\n/**\n *\n * Validate that all of the validators passes\n * @params each parameter is an array of validators, those validators will be verified against the wrapped function argument which in the same place\n * @throws if any of the validators fails, an error with the relevant message will be thrown\n */\nexport const withValidations =\n  (...argsRules: Validator[][]) =>\n  <T extends Array<any>, U>(fn: (...args: T) => U) =>\n  (...args: T): U => {\n    argsRules.forEach((rulesArr, i) =>\n      createValidation(...rulesArr).validate(args[i])\n    );\n\n    return fn(...args);\n  };\n\nexport const string = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n];\n\nexport const isStringOrUndefinedValidator = (fieldName: string) => [\n  isStringOrUndefined(`\"${fieldName}\" must be string or undefined`),\n];\n\nexport const stringNonEmpty = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isNotEmpty(`\"${fieldName}\" must not be empty`),\n];\nexport const stringEmail = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isEmail(),\n];\nexport const stringPhone = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isPhone(),\n];\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport { ExchangeAccessKeyResponse, SdkResponse } from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst withExchangeValidations = withValidations(stringNonEmpty('accessKey'));\n\nconst withAccessKeys = (httpClient: HttpClient) => ({\n  exchange: withExchangeValidations(\n    (accessKey: string): Promise<SdkResponse<ExchangeAccessKeyResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.accessKey.exchange, {}, { token: accessKey })\n      )\n  ),\n});\n\nexport default withAccessKeys;\n","type DeviceInfo = {\n  webAuthnSupport?: boolean;\n};\n\ntype LastAuth = {\n  authMethod?: AuthMethod;\n  oauthProvider?: string;\n  name?: string;\n  loginId?: string;\n};\n\ntype RedirectAuth = {\n  callbackUrl: string;\n  codeChallenge: string;\n};\n\ntype AuthMethod =\n  | 'magiclink'\n  | 'enchantedlink'\n  | 'otp'\n  | 'totp'\n  | 'oauth'\n  | 'saml'\n  | 'webauthn';\n\nexport type SdkFn = (...args: any[]) => Promise<SdkResponse<ResponseData>>;\n\nexport type MaskedPhone = {\n  maskedPhone: string;\n};\n\nexport type MaskedEmail = {\n  maskedEmail: string;\n};\n\n/** User base details from Descope API */\nexport type User = {\n  email?: string;\n  name?: string;\n  phone?: string;\n};\n\n/** User extended details from Descope API */\nexport type UserResponse = User & {\n  loginIds: string[];\n  userId: string;\n  verifiedEmail?: boolean;\n  verifiedPhone?: boolean;\n  picture?: string;\n  roleNames?: string[];\n  userTenants?: UserTenant[];\n  createTime: number;\n  totp: boolean;\n  saml: boolean;\n  oauth?: Record<string, boolean>;\n};\n\n/** A tenant association mapping  */\nexport type UserTenant = {\n  tenantId: string;\n  roleNames?: string[];\n};\n\n/** Login options to be added to the different authentication methods */\nexport type LoginOptions = {\n  stepup?: boolean;\n  mfa?: boolean;\n  customClaims?: Record<string, any>;\n};\n\n/** Authentication info result from the various JWT validations  */\nexport type JWTResponse = {\n  sessionJwt: string;\n  refreshJwt?: string;\n  cookieDomain?: string;\n  cookiePath?: string;\n  cookieMaxAge?: number;\n  cookieExpiration?: number;\n  user?: UserResponse;\n  firstSeen?: boolean;\n};\n\n/** Authentication info result from exchanging access keys for a session */\nexport type ExchangeAccessKeyResponse = {\n  keyId: string;\n  sessionJwt: string;\n  expiration: number;\n};\n\n/** The response returned from the various start webauthn functions */\nexport type WebAuthnStartResponse = {\n  transactionId: string;\n  options: string;\n  create: boolean;\n};\n\n/** Enchanted link response */\nexport type EnchantedLinkResponse = {\n  /** Pending reference URL to poll while waiting for user to click magic link */\n  pendingRef: string;\n  /** Link id, on which link the user should click */\n  linkId: string;\n  /** Email to which the link was sent to */\n  maskedEmail: string;\n};\n\n/** URL response to redirect user in case of OAuth or SSO */\nexport type URLResponse = {\n  url: string;\n};\n\n/** TOTP response with the TOTP details */\nexport type TOTPResponse = {\n  provisioningURL: string;\n  image: string;\n  key: string;\n};\n\n/** Password reset response with details according to response method */\nexport type PasswordResetResponse = {\n  resetMethod: string;\n  pendingRef?: string;\n  linkId?: string;\n  maskedEmail: string;\n};\n\n/** A subset of the password policy that can be checked on the client side for better UX */\nexport type PasswordPolicyResponse = {\n  minLength: number;\n  lowercase: boolean;\n  uppercase: boolean;\n  number: boolean;\n  nonAlphanumeric: boolean;\n};\n\n/** Phone delivery methods which are currently supported */\nexport enum DeliveryPhone {\n  sms = 'sms',\n  whatsapp = 'whatsapp',\n}\n\nexport enum DeliveryEmail {\n  email = 'email',\n}\n\n/** All delivery methods currently supported */\nexport type DeliveryMethods = DeliveryPhone | DeliveryEmail;\n\nexport const DeliveryMethods = {\n  ...DeliveryPhone,\n  ...DeliveryEmail,\n} as const;\n\n/** All flow execution statuses\n *  - waiting - flow execution is waiting for user interaction\n *  - running - flow execution is currently running\n *  - completed - flow execution completed successfully\n *  - failed - flow execution failed\n */\nexport enum FlowStatus {\n  waiting = 'waiting',\n  running = 'running',\n  completed = 'completed',\n  failed = 'failed',\n}\n\n/** All flow response action\n *  - screen - next action is to render  screen\n *  - poll - next action is poll for next after timeout\n *  - redirect - next action is to redirect (redirection details in 'redirect' attribute)\n *  - webauthnCreate/webauthnGet - next action is to prompt webauthn (details in 'webauthn' attribute)\n *  - none - no next action\n */\nexport type FlowAction =\n  | 'screen'\n  | 'poll'\n  | 'redirect'\n  | 'webauthnCreate'\n  | 'webauthnGet'\n  | 'none';\n\n/** Flow response with flow execution details */\nexport type FlowResponse = {\n  // current execution identifier\n  executionId: string;\n  // current step identifier\n  stepId: string;\n  // flow execution status\n  status: FlowStatus;\n  // the next required action\n  action: FlowAction;\n  // screen data - if action is 'screen'\n  screen?: {\n    // screen identifier\n    id: string;\n    // extra dynamic state required for rendering screen\n    state: Record<string, any>;\n  };\n  // redirect data - if action is 'redirect'\n  redirect?: {\n    url: string;\n  };\n  // webauthn data - if action is one of 'webauthnCreate', 'webauthnGet'\n  webauthn?: {\n    transactionId: string;\n    options: string;\n    create: boolean;\n  };\n  // an error that occurred during flow execution, used for debugging / integrating\n  error?: {\n    code: string;\n    description: string;\n    message: string;\n  };\n  // authentication information response, if response is authenticated\n  authInfo?: JWTResponse;\n  lastAuth?: Pick<LastAuth, 'authMethod' | 'oauthProvider'>;\n};\n\nexport type Options = {\n  redirectUrl?: string;\n  tenant?: string;\n  deviceInfo?: DeviceInfo;\n  lastAuth?: LastAuth;\n  redirectAuth?: RedirectAuth;\n  oidcIdpStateId?: string;\n};\n\nexport type ResponseData = Record<string, any>;\n\n/**\n * Response from our SDK calls which includes the result (ok, code, error).\n * The relevant data is provided in the more specific interfaces extending SdkResponse.\n */\nexport type SdkResponse<T extends ResponseData> = {\n  code?: number;\n  ok: boolean;\n  response?: Response;\n  error?: {\n    errorCode: string;\n    errorDescription: string;\n    errorMessage?: string;\n    retryAfter?: string;\n  };\n  data?: T;\n};\n\n/** Different delivery method */\nexport type Deliveries<T extends Record<DeliveryMethods, SdkFn>> = {\n  [S in DeliveryMethods]: T[S];\n};\n\nexport type DeliveriesPhone<T extends Record<DeliveryPhone, SdkFn> | SdkFn> = {\n  [S in DeliveryPhone]: T extends Record<DeliveryPhone, SdkFn> ? T[S] : T;\n};\n\n/** Map different functions to email vs phone (sms, whatsapp) */\nexport type DeliveriesMap<EmailFn extends SdkFn, PhoneFn extends SdkFn> = {\n  [S in DeliveryMethods]: S extends 'email' ? EmailFn : PhoneFn;\n};\n\n/** Logger type that supports the given levels (debug, log, error) */\nexport type Logger = Pick<Console, 'debug' | 'log' | 'error' | 'warn'>;\n\nexport type UpdateOptions<T extends boolean> = {\n  addToLoginIDs?: T;\n  onMergeUseExisting?: T extends true ? boolean : never;\n};\n","import {\n  stringNonEmpty,\n  withValidations,\n  stringPhone,\n  stringEmail,\n} from '../validations';\n\nexport const loginIdValidations = stringNonEmpty('loginId');\nexport const withVerifyValidations = withValidations(stringNonEmpty('token'));\nexport const withSignValidations = withValidations(loginIdValidations);\nexport const withWaitForSessionValidations = withValidations(\n  stringNonEmpty('pendingRef')\n);\nexport const withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone')\n);\nexport const withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email')\n);\n","import {\n  apiPaths,\n  ENCHANTED_LINK_MAX_POLLING_TIMEOUT_MS,\n  ENCHANTED_LINK_MIN_POLLING_INTERVAL_MS,\n} from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  SdkResponse,\n  JWTResponse,\n  EnchantedLinkResponse,\n  User,\n  LoginOptions,\n  UpdateOptions,\n} from '../types';\nimport { EnchantedLink, Routes, WaitForSessionConfig } from './types';\nimport {\n  withWaitForSessionValidations,\n  withSignValidations,\n  withVerifyValidations,\n  withUpdateEmailValidations,\n} from './validations';\n\n/** Polling configuration with defaults and normalizing checks */\nconst normalizeWaitForSessionConfig = ({\n  pollingIntervalMs = ENCHANTED_LINK_MIN_POLLING_INTERVAL_MS,\n  timeoutMs = ENCHANTED_LINK_MAX_POLLING_TIMEOUT_MS,\n} = {}) => ({\n  pollingIntervalMs: Math.max(\n    pollingIntervalMs || ENCHANTED_LINK_MIN_POLLING_INTERVAL_MS,\n    ENCHANTED_LINK_MIN_POLLING_INTERVAL_MS\n  ),\n  timeoutMs: Math.min(\n    timeoutMs || ENCHANTED_LINK_MAX_POLLING_TIMEOUT_MS,\n    ENCHANTED_LINK_MAX_POLLING_TIMEOUT_MS\n  ),\n});\n\nconst withEnchantedLink = (httpClient: HttpClient) => ({\n  verify: withVerifyValidations(\n    (token: string): Promise<SdkResponse<never>> =>\n      transformResponse(\n        httpClient.post(apiPaths.enchantedLink.verify, { token })\n      )\n  ),\n\n  signIn: withSignValidations(\n    (\n      loginId: string,\n      URI?: string,\n      loginOptions?: LoginOptions,\n      token?: string\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signIn, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n            loginOptions,\n          },\n          { token }\n        )\n      )\n  ) as EnchantedLink[Routes.signIn],\n\n  signUpOrIn: withSignValidations(\n    (\n      loginId: string,\n      URI?: string\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signUpOrIn, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n          }\n        )\n      )\n  ) as EnchantedLink[Routes.signIn],\n\n  signUp: withSignValidations(\n    (\n      loginId: string,\n      URI?: string,\n      user?: User\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signUp, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n            user,\n          }\n        )\n      )\n  ) as EnchantedLink[Routes.signUp],\n\n  waitForSession: withWaitForSessionValidations(\n    (\n      pendingRef: string,\n      config?: WaitForSessionConfig\n    ): Promise<SdkResponse<JWTResponse>> =>\n      new Promise((resolve) => {\n        const { pollingIntervalMs, timeoutMs } =\n          normalizeWaitForSessionConfig(config);\n        let timeout: NodeJS.Timeout | undefined;\n        const interval = setInterval(async () => {\n          const resp = await httpClient.post(apiPaths.enchantedLink.session, {\n            pendingRef,\n          });\n          if (resp.ok) {\n            clearInterval(interval);\n            if (timeout) clearTimeout(timeout);\n            resolve(transformResponse(Promise.resolve(resp)));\n          }\n        }, pollingIntervalMs);\n\n        timeout = setTimeout(() => {\n          resolve({\n            error: {\n              errorDescription: `Session polling timeout exceeded: ${timeoutMs}ms`,\n              errorCode: '0',\n            },\n            ok: false,\n          });\n          clearInterval(interval);\n        }, timeoutMs);\n      })\n  ),\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        URI?: string,\n        token?: string,\n        updateOptions?: UpdateOptions<T>\n      ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.enchantedLink.update.email,\n            { loginId, email, URI, ...updateOptions },\n            { token }\n          )\n        )\n    ),\n  },\n});\n\nexport default withEnchantedLink;\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { transformResponse } from '../helpers';\nimport { FlowResponse, Options, SdkResponse } from '../types';\nimport { stringNonEmpty, withValidations } from '../validations';\nimport { FlowInput } from './types';\n\nconst withStartValidations = withValidations(stringNonEmpty('flowId'));\nconst withNextValidations = withValidations(\n  stringNonEmpty('executionId'),\n  stringNonEmpty('stepId'),\n  stringNonEmpty('interactionId')\n);\n\nconst withFlow = (httpClient: HttpClient) => ({\n  start: withStartValidations(\n    (\n      flowId: string,\n      options?: Options,\n      conditionInteractionId?: string,\n      interactionId?: string,\n      input?: FlowInput,\n      version?: number\n    ): Promise<SdkResponse<FlowResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.flow.start, {\n          flowId,\n          options,\n          conditionInteractionId,\n          interactionId,\n          input,\n          version,\n        })\n      )\n  ),\n  next: withNextValidations(\n    (\n      executionId: string,\n      stepId: string,\n      interactionId: string,\n      input?: FlowInput,\n      version?: number\n    ): Promise<SdkResponse<FlowResponse>> => {\n      return transformResponse(\n        httpClient.post(apiPaths.flow.next, {\n          executionId,\n          stepId,\n          interactionId,\n          input,\n          version,\n        })\n      );\n    }\n  ),\n});\n\nexport default withFlow;\n","import {\n  stringNonEmpty,\n  withValidations,\n  stringPhone,\n  stringEmail,\n} from '../validations';\n\nexport const loginIdValidations = stringNonEmpty('loginId');\nexport const withVerifyValidations = withValidations(stringNonEmpty('token'));\nexport const withSignValidations = withValidations(loginIdValidations);\nexport const withWaitForSessionValidations = withValidations(\n  stringNonEmpty('pendingRef')\n);\nexport const withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone')\n);\nexport const withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email')\n);\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  DeliveryPhone,\n  SdkResponse,\n  JWTResponse,\n  User,\n  LoginOptions,\n  MaskedEmail,\n  UpdateOptions,\n} from '../types';\nimport { MagicLink, Routes } from './types';\nimport {\n  withSignValidations,\n  withVerifyValidations,\n  withUpdateEmailValidations,\n  withUpdatePhoneValidations,\n} from './validations';\n\nconst withMagicLink = (httpClient: HttpClient) => ({\n  verify: withVerifyValidations(\n    (token: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.magicLink.verify, { token }))\n  ),\n\n  signIn: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (\n          loginId: string,\n          URI?: string,\n          loginOptions?: LoginOptions,\n          token?: string\n        ) =>\n          transformResponse(\n            httpClient.post(\n              pathJoin(apiPaths.magicLink.signIn, delivery),\n              { loginId, URI, loginOptions },\n              { token }\n            )\n          )\n      ),\n    }),\n    {}\n  ) as MagicLink[Routes.signIn],\n\n  signUp: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, URI?: string, user?: User) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.magicLink.signUp, delivery), {\n              loginId,\n              URI,\n              user,\n            })\n          )\n      ),\n    }),\n    {}\n  ) as MagicLink[Routes.signUp],\n\n  signUpOrIn: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations((loginId: string, URI?: string) =>\n        transformResponse(\n          httpClient.post(pathJoin(apiPaths.magicLink.signUpOrIn, delivery), {\n            loginId,\n            URI,\n          })\n        )\n      ),\n    }),\n    {}\n  ) as MagicLink[Routes.signIn],\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        URI?: string,\n        token?: string,\n        updateOptions? : UpdateOptions<T>\n      ): Promise<SdkResponse<MaskedEmail>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.magicLink.update.email,\n            { loginId, email, URI, ...updateOptions },\n            { token }\n          )\n        )\n    ),\n    phone: Object.keys(DeliveryPhone).reduce(\n      (acc, delivery) => ({\n        ...acc,\n        [delivery]: withUpdatePhoneValidations(\n          <T extends boolean>(\n            loginId: string,\n            phone: string,\n            URI?: string,\n            token?: string,\n            updateOptions? : UpdateOptions<T>\n          ) =>\n            transformResponse(\n              httpClient.post(\n                pathJoin(apiPaths.magicLink.update.phone, delivery),\n                { loginId, phone, URI, ...updateOptions },\n                { token }\n              )\n            )\n        ),\n      }),\n      {}\n    ) as MagicLink[Routes.updatePhone],\n  },\n});\n\nexport default withMagicLink;\n","import { SdkResponse, URLResponse, JWTResponse } from '../types';\n\nenum OAuthProviders {\n  facebook = 'facebook',\n  github = 'github',\n  google = 'google',\n  microsoft = 'microsoft',\n  gitlab = 'gitlab',\n  apple = 'apple',\n  discord = 'discord',\n  linkedin = 'linkedin',\n}\n\ntype StartFn = <B extends { redirect: boolean }>(\n  redirectURL?: string,\n  config?: B\n) => Promise<SdkResponse<URLResponse>>;\ntype VerifyFn = (code: string) => Promise<SdkResponse<JWTResponse>>;\n\ntype Providers<T> = Record<keyof typeof OAuthProviders, T>;\n\nexport type Oauth = {\n  start: Providers<StartFn>;\n  verify: Providers<VerifyFn>;\n};\n\nexport { OAuthProviders };\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { SdkResponse, URLResponse, JWTResponse, LoginOptions } from '../types';\nimport { transformResponse } from '../helpers';\nimport { Oauth, OAuthProviders } from './types';\nimport { stringNonEmpty, withValidations } from '../validations';\n\nconst withExchangeValidations = withValidations(stringNonEmpty('code'));\n\nconst withOauth = (httpClient: HttpClient) => ({\n  start: Object.keys(OAuthProviders).reduce(\n    (acc, provider) => ({\n      ...acc,\n      [provider]: (\n        redirectUrl?: string,\n        loginOptions?: LoginOptions,\n        token?: string\n      ) =>\n        transformResponse(\n          httpClient.post(apiPaths.oauth.start, loginOptions || {}, {\n            queryParams: {\n              provider,\n              ...(redirectUrl && { redirectURL: redirectUrl }),\n            },\n            token,\n          })\n        ),\n    }),\n    {}\n  ) as Oauth['start'],\n  exchange: withExchangeValidations(\n    (code: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.oauth.exchange, { code }))\n  ),\n});\n\nexport default withOauth;\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  User,\n  SdkResponse,\n  JWTResponse,\n  DeliveryPhone,\n  LoginOptions,\n  MaskedEmail,\n  UpdateOptions,\n} from '../types';\nimport {\n  stringEmail,\n  stringNonEmpty,\n  stringPhone,\n  withValidations,\n} from '../validations';\nimport { Otp, Routes } from './types';\n\nconst loginIdValidations = stringNonEmpty('loginId');\nconst withVerifyValidations = withValidations(\n  loginIdValidations,\n  stringNonEmpty('code')\n);\nconst withSignValidations = withValidations(loginIdValidations);\nconst withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone')\n);\nconst withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email')\n);\n\nconst withOtp = (httpClient: HttpClient) => ({\n  verify: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withVerifyValidations(\n        (loginId: string, code: string): Promise<SdkResponse<JWTResponse>> =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.otp.verify, delivery), {\n              code,\n              loginId,\n            })\n          )\n      ),\n    }),\n    {}\n  ) as Otp[Routes.verify],\n\n  signIn: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, loginOptions?: LoginOptions, token?: string) =>\n          transformResponse(\n            httpClient.post(\n              pathJoin(apiPaths.otp.signIn, delivery),\n              { loginId, loginOptions },\n              { token }\n            )\n          )\n      ),\n    }),\n    {}\n  ) as Otp[Routes.signIn],\n\n  signUp: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations((loginId: string, user?: User) =>\n        transformResponse(\n          httpClient.post(pathJoin(apiPaths.otp.signUp, delivery), {\n            loginId,\n            user,\n          })\n        )\n      ),\n    }),\n    {}\n  ) as Otp[Routes.signUp],\n\n  signUpOrIn: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations((loginId: string) =>\n        transformResponse(\n          httpClient.post(pathJoin(apiPaths.otp.signUpOrIn, delivery), {\n            loginId,\n          })\n        )\n      ),\n    }),\n    {}\n  ) as Otp[Routes.signIn],\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        token?: string,\n        updateOptions? : UpdateOptions<T>\n      ): Promise<SdkResponse<MaskedEmail>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.otp.update.email,\n            { loginId, email, ...updateOptions },\n            { token }\n          )\n        )\n    ),\n    phone: Object.keys(DeliveryPhone).reduce(\n      (acc, delivery) => ({\n        ...acc,\n        [delivery]: withUpdatePhoneValidations(\n          <T extends boolean>(\n            loginId: string,\n            phone: string,\n            token?: string,\n            updateOptions? : UpdateOptions<T>\n          ) =>\n            transformResponse(\n              httpClient.post(\n                pathJoin(apiPaths.otp.update.phone, delivery),\n                { loginId, phone, ...updateOptions },\n                { token }\n              )\n            )\n        ),\n      }),\n      {}\n    ) as Otp[Routes.updatePhone],\n  },\n});\n\nexport default withOtp;\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport { SdkResponse, URLResponse, JWTResponse, LoginOptions } from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst withStartValidations = withValidations(stringNonEmpty('tenant'));\nconst withExchangeValidations = withValidations(stringNonEmpty('code'));\n\nconst withSaml = (httpClient: HttpClient) => ({\n  start: withStartValidations(\n    (\n      tenantIdOrEmail: string,\n      redirectUrl?: string,\n      loginOptions?: LoginOptions,\n      token?: string\n    ): Promise<SdkResponse<URLResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.saml.start, loginOptions || {}, {\n          queryParams: { tenant: tenantIdOrEmail, redirectURL: redirectUrl },\n          token,\n        })\n      )\n  ),\n  exchange: withExchangeValidations(\n    (code: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.saml.exchange, { code }))\n  ),\n});\n\nexport default withSaml;\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport {\n  User,\n  SdkResponse,\n  JWTResponse,\n  TOTPResponse,\n  LoginOptions,\n} from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst loginIdValidations = stringNonEmpty('loginId');\nconst withVerifyValidations = withValidations(\n  loginIdValidations,\n  stringNonEmpty('code')\n);\nconst withSignUpValidations = withValidations(loginIdValidations);\nconst withUpdateValidations = withValidations(loginIdValidations);\n\nconst withTotp = (httpClient: HttpClient) => ({\n  signUp: withSignUpValidations(\n    (loginId: string, user?: User): Promise<SdkResponse<TOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.totp.signUp, { loginId, user })\n      )\n  ),\n\n  verify: withVerifyValidations(\n    (\n      loginId: string,\n      code: string,\n      loginOptions?: LoginOptions,\n      token?: string\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.totp.verify,\n          { loginId, code, loginOptions },\n          { token }\n        )\n      )\n  ),\n\n  update: withUpdateValidations(\n    (loginId: string, token?: string): Promise<SdkResponse<TOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.totp.update, { loginId }, { token })\n      )\n  ),\n});\n\nexport default withTotp;\n","import { stringNonEmpty, withValidations } from '../validations';\n\nconst loginIdValidation = stringNonEmpty('loginId');\nconst newPasswordValidation = stringNonEmpty('newPassword');\nexport const withSignValidations = withValidations(\n  loginIdValidation,\n  stringNonEmpty('password')\n);\nexport const withSendResetValidations = withValidations(loginIdValidation);\nexport const withUpdateValidation = withValidations(\n  loginIdValidation,\n  newPasswordValidation\n);\nexport const withReplaceValidation = withValidations(\n  loginIdValidation,\n  stringNonEmpty('oldPassword'),\n  newPasswordValidation\n);\n","import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { transformResponse } from '../helpers';\nimport {\n  withSignValidations,\n  withSendResetValidations,\n  withUpdateValidation,\n  withReplaceValidation,\n} from './validations';\nimport {\n  SdkResponse,\n  JWTResponse,\n  User,\n  PasswordResetResponse,\n  PasswordPolicyResponse,\n} from '../types';\n\nconst withPassword = (httpClient: HttpClient) => ({\n  signUp: withSignValidations(\n    (\n      loginId: string,\n      password: string,\n      user?: User\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.signUp, {\n          loginId,\n          password,\n          user,\n        })\n      )\n  ),\n\n  signIn: withSignValidations(\n    (loginId: string, password: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.signIn, {\n          loginId,\n          password,\n        })\n      )\n  ),\n\n  sendReset: withSendResetValidations(\n    (\n      loginId: string,\n      redirectUrl?: string\n    ): Promise<SdkResponse<PasswordResetResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.sendReset, { loginId, redirectUrl })\n      )\n  ),\n\n  update: withUpdateValidation(\n    (\n      loginId: string,\n      newPassword: string,\n      token?: string\n    ): Promise<SdkResponse<never>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.password.update,\n          {\n            loginId,\n            newPassword,\n          },\n          { token }\n        )\n      )\n  ),\n\n  replace: withReplaceValidation(\n    (\n      loginId: string,\n      oldPassword: string,\n      newPassword: string\n    ): Promise<SdkResponse<never>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.replace, {\n          loginId,\n          oldPassword,\n          newPassword,\n        })\n      )\n  ),\n\n  policy: (): Promise<SdkResponse<PasswordPolicyResponse>> =>\n    transformResponse(httpClient.get(apiPaths.password.policy)),\n});\n\nexport default withPassword;\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport {\n  SdkResponse,\n  ResponseData,\n  LoginOptions,\n  JWTResponse,\n  WebAuthnStartResponse,\n} from './types';\nimport { string, stringNonEmpty, withValidations } from './validations';\n\nconst loginIdStringValidations = string('loginId');\nconst loginIdNonEmptyValidations = stringNonEmpty('loginId');\nconst originValidations = stringNonEmpty('origin');\n\nconst withSignUpStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations,\n  stringNonEmpty('name')\n);\nconst withSignUpOrInStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations\n);\nconst withSignInStartValidations = withValidations(\n  loginIdStringValidations,\n  originValidations\n);\nconst withUpdateStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations,\n  stringNonEmpty('token')\n);\nconst withFinishValidations = withValidations(\n  stringNonEmpty('transactionId'),\n  stringNonEmpty('response')\n);\n\nconst withWebauthn = (httpClient: HttpClient) => ({\n  signUp: {\n    start: withSignUpStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        name: string\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUp.start, {\n            user: {\n              loginId,\n              name,\n            },\n            origin,\n          })\n        )\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string\n      ): Promise<SdkResponse<JWTResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUp.finish, {\n            transactionId,\n            response,\n          })\n        )\n    ),\n  },\n\n  signIn: {\n    start: withSignInStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        loginOptions?: LoginOptions,\n        token?: string\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.webauthn.signIn.start,\n            { loginId, origin, loginOptions },\n            { token }\n          )\n        )\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string\n      ): Promise<SdkResponse<JWTResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signIn.finish, {\n            transactionId,\n            response,\n          })\n        )\n    ),\n  },\n\n  signUpOrIn: {\n    start: withSignUpOrInStartValidations(\n      (\n        loginId: string,\n        origin: string\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUpOrIn.start, {\n            loginId,\n            origin,\n          })\n        )\n    ),\n  },\n\n  update: {\n    start: withUpdateStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        token: string\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.webauthn.update.start,\n            { loginId, origin },\n            { token }\n          )\n        )\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string\n      ): Promise<SdkResponse<ResponseData>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.update.finish, {\n            transactionId,\n            response,\n          })\n        )\n    ),\n  },\n});\n\nexport default withWebauthn;\n","import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport withAccessKeys from './accesskey';\nimport withEnchantedLink from './enchantedLink';\nimport withFlow from './flow';\nimport {\n  getTenants,\n  getJwtPermissions,\n  getJwtRoles,\n  isJwtExpired,\n  transformResponse,\n} from './helpers';\nimport withMagicLink from './magicLink';\nimport withOauth from './oauth';\nimport withOtp from './otp';\nimport withSaml from './saml';\nimport withTotp from './totp';\nimport withPassword from './password';\nimport { JWTResponse, UserResponse } from './types';\nimport {\n  stringNonEmpty,\n  withValidations,\n  isStringOrUndefinedValidator,\n} from './validations';\nimport withWebauthn from './webauthn';\n\nconst withJwtValidations = withValidations(stringNonEmpty('token'));\nconst withOptionalTokenValidations = withValidations(\n  isStringOrUndefinedValidator('token')\n);\n\n/** Returns Descope SDK with all available operations */\nexport default (httpClient: HttpClient) => ({\n  accessKey: withAccessKeys(httpClient),\n  otp: withOtp(httpClient),\n  magicLink: withMagicLink(httpClient),\n  enchantedLink: withEnchantedLink(httpClient),\n  oauth: withOauth(httpClient),\n  saml: withSaml(httpClient),\n  totp: withTotp(httpClient),\n  webauthn: withWebauthn(httpClient),\n  password: withPassword(httpClient),\n  flow: withFlow(httpClient),\n  refresh: withOptionalTokenValidations((token?: string) =>\n    transformResponse<JWTResponse>(\n      httpClient.post(apiPaths.refresh, {}, { token })\n    )\n  ),\n  logout: withOptionalTokenValidations((token?: string) =>\n    transformResponse<never>(httpClient.post(apiPaths.logout, {}, { token }))\n  ),\n  logoutAll: withOptionalTokenValidations((token?: string) =>\n    transformResponse<never>(httpClient.post(apiPaths.logoutAll, {}, { token }))\n  ),\n  me: withOptionalTokenValidations((token?: string) =>\n    transformResponse<UserResponse>(httpClient.get(apiPaths.me, { token }))\n  ),\n  isJwtExpired: withJwtValidations(isJwtExpired),\n  getTenants: withJwtValidations(getTenants),\n  getJwtPermissions: withJwtValidations(getJwtPermissions),\n  getJwtRoles: withJwtValidations(getJwtRoles),\n  httpClient,\n});\n","import { DEFAULT_BASE_API_URL } from './constants';\nimport createHttpClient from './httpClient';\nimport { AfterRequest, BeforeRequest, Fetch, Hooks } from './httpClient/types';\nimport createSdk from './sdk';\nimport { Logger } from './sdk/types';\nimport { stringNonEmpty, withValidations } from './sdk/validations';\nimport { hasPathValue } from './sdk/validations/validators';\n\ntype SdkConfig = {\n  projectId: string;\n  logger?: Logger;\n  baseUrl?: string;\n  hooks?: Hooks;\n  cookiePolicy?: RequestCredentials;\n  baseHeaders?: HeadersInit;\n  fetch?: Fetch;\n};\n\n/** Validate we have non-empty project id */\nconst withSdkConfigValidations = withValidations([\n  hasPathValue('projectId', stringNonEmpty('projectId')),\n]);\n\n/** Add the ability to pass multiple hooks instead of one when creating an SDK instance */\nconst withMultipleHooks =\n  <T extends object>(createSdk: (config: SdkConfig) => T) =>\n  (\n    config: Omit<SdkConfig, 'hooks'> & {\n      hooks?: {\n        beforeRequest?: BeforeRequest | BeforeRequest[];\n        afterRequest?: AfterRequest | AfterRequest[];\n      };\n    }\n  ) => {\n    const beforeRequestHooks = [].concat(config.hooks?.beforeRequest || []);\n    const afterRequestHooks = [].concat(config.hooks?.afterRequest || []);\n\n    const beforeRequest: BeforeRequest = (config) =>\n      beforeRequestHooks?.reduce((acc, fn) => fn(acc), config);\n    const afterRequest: AfterRequest = async (req, res) => {\n      const results = await Promise.allSettled(\n        afterRequestHooks?.map((fn) => fn(req, res?.clone()))\n      );\n      // eslint-disable-next-line no-console\n      results.forEach(\n        (result) =>\n          result.status === 'rejected' && config.logger?.error(result.reason)\n      );\n    };\n\n    return createSdk({ ...config, hooks: { beforeRequest, afterRequest } });\n  };\n\n/** Descope SDK client */\nexport default withSdkConfigValidations(\n  withMultipleHooks(\n    ({\n      projectId,\n      logger,\n      baseUrl,\n      hooks,\n      cookiePolicy,\n      baseHeaders = {},\n      fetch,\n    }: SdkConfig) =>\n      createSdk(\n        createHttpClient({\n          baseUrl: baseUrl || DEFAULT_BASE_API_URL,\n          projectId,\n          logger,\n          hooks,\n          cookiePolicy,\n          baseConfig: { baseHeaders },\n          fetch,\n        })\n      )\n  )\n);\n","import createSdk from './createSdk';\nimport { HTTPMethods, RequestConfig } from './httpClient/types';\nimport { OAuthProviders } from './sdk/oauth/types';\nimport { DeliveryMethods } from './sdk/types';\n\n/** Descope SDK client with delivery methods enum.\n *\n * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}\n * @example Usage\n *\n * ```js\n * import descopeSdk from '@descope/core-js-sdk';\n *\n * const myProjectId = 'xxx';\n * const sdk = descopeSdk({ projectId: myProjectId });\n *\n * const userLoginId = 'loginId';\n * sdk.otp.signIn.email(userLoginId);\n * const jwtResponse = sdk.otp.verify.email(userIdentifier, codeFromEmail);\n * ```\n */\nexport default Object.assign(createSdk, { DeliveryMethods });\n\nexport { transformResponse } from './sdk/helpers';\nexport type {\n  EnchantedLinkResponse,\n  ExchangeAccessKeyResponse,\n  FlowAction,\n  FlowResponse,\n  FlowStatus,\n  JWTResponse,\n  ResponseData,\n  SdkResponse,\n  TOTPResponse,\n  URLResponse,\n  UserResponse,\n} from './sdk/types';\nexport * from './utils';\nexport { default as HttpStatusCodes } from './constants/httpStatusCodes';\nexport type { SdkFnWrapper } from './utils';\nexport type { HTTPMethods, RequestConfig };\n\n/** Type to restrict to valid delivery methods */\nexport type DeliveryMethod = keyof typeof DeliveryMethods;\n/** Type to restrict to valid OAuth providers */\nexport type OAuthProvider = keyof typeof OAuthProviders;\n","/* eslint-disable import/exports-last */\nimport { ResponseData } from '../../sdk/types';\nimport { SdkFnWrapper, ReplacePaths, SdkFnsPaths } from './types';\n\n/**\n * A wrapper function that allows to wrap multiple Sdk function\n * @param obj: The Sdk instance you want to wrap\n * @param paths: A readonly list of paths of the functions you want to wrap\n * @param wrapper: Your wrapper function, it should gets an Sdk function and return a new Sdk function\n * @returns a mutated instance of the Sdk with updated type definitions based on your wrapper return type\n *\n * Usage example:\n *\n * // Assuming this is our SDK instance\n * const sdk = {\n *    me: (token) => {...}\n *    flow: {\n *       start: (...params) => {...}\n *       next: (...params) => {...}\n *    }\n *    ...\n * }\n *\n * // This is our wrapper\n * const wrapper = (sdkFn) => async (...args) => {\n *    const sdkResponse = await sdkFn(...args)\n *\n *    // Modify return value\n *    return {...sdkResponse, data: {...sdkResponse.data, myCustomAttribute: 'hello'}}\n * }\n *\n * // And those are the paths we want to wrap\n * const paths = ['flow.start', 'flow.next'] as const // You MUST add as const!\n *\n * // We can wrap our SDK functions with the wrapper we created in this way\n * const newlyTypedSdk = wrapWith(sdk, paths, wrapper)\n *\n * Now the 2 wrapped functions will have the updated type based on the wrapper return value\n */\n\nconst wrapWith = <\n  Obj extends object,\n  Paths extends ReadonlyArray<SdkFnsPaths<Obj>>,\n  WrapperData extends ResponseData\n>(\n  obj: Obj,\n  paths: Paths,\n  wrapper: SdkFnWrapper<WrapperData>\n): ReplacePaths<Obj, Paths, WrapperData> => {\n  paths.forEach((path) => {\n    const sections = path.split('.');\n    let section = sections.shift();\n    let currentRef: Record<string, any> = obj;\n\n    while (sections.length > 0) {\n      currentRef = currentRef[section];\n\n      if (!section || !currentRef) {\n        throw Error(\n          `Invalid path \"${path}\", \"${section}\" is missing or has no value`\n        );\n      }\n\n      section = sections.shift();\n    }\n\n    if (typeof currentRef[section] !== 'function') {\n      throw Error(`\"${path}\" is not a function`);\n    }\n    const origFn = currentRef[section];\n    currentRef[section] = wrapper(origFn);\n  });\n\n  return obj as any;\n};\n\nexport default wrapWith;\n"],"names":["apiPaths","exchange","verify","signIn","signUp","update","email","phone","signUpOrIn","session","start","finish","sendReset","replace","policy","next","ENCHANTED_LINK_MIN_POLLING_INTERVAL_MS","ENCHANTED_LINK_MAX_POLLING_TIMEOUT_MS","httpLogBuilder","msg","headers","headersObj","entries","Object","fromEntries","Headers","JSON","stringify","this","body","Body","url","Url","toString","method","Method","title","Title","status","Status","build","keys","flatMap","key","join","createFetchLogger","logger","receivedFetch","fetchInternal","fetch","async","args","resp","respText","text","Promise","resolve","json","parse","clone","fetchWrapper","warn","Error","log","buildRequestLog","ok","respBody","statusText","buildResponseLog","HTTPMethods","mergeHeaders","sources","reduce","acc","source","srcArr","Array","isArray","from","getSrcArr","_","value","serializeBody","undefined","createAuthorizationHeader","projectId","token","bearer","Authorization","createHttpClient","baseUrl","baseConfig","hooks","cookiePolicy","fetchWithLogger","sendRequest","config","requestConfig","beforeRequest","path","queryParams","res","URL","search","URLSearchParams","urlBuilder","baseHeaders","credentials","afterRequest","get","post","put","delete","HttpStatusCodes","TOO_MANY_REQUESTS","getJwtAuthorizationItems","tenant","claim","claims","parseJwt","_a","tenants","items","jwtDecode","isJwtExpired","exp","Date","getTime","getTenants","getJwtPermissions","getJwtRoles","pathJoin","transformResponse","response","transform","ret","code","data","error","assign","retryAfter","Number","parseInt","createValidator","rule","defaultMsg","val","createValidation","validators","validate","forEach","validator","errMsg","regexMatch","regex","test","validateEmail","validatePhone","isEmail","isPhone","isNotEmpty","min","length","isString","isUndefined","isStringOrUndefined","errors","filter","withValidations","argsRules","fn","rulesArr","i","stringNonEmpty","fieldName","stringEmail","stringPhone","withExchangeValidations","withAccessKeys","httpClient","accessKey","DeliveryPhone","DeliveryEmail","DeliveryMethods","FlowStatus","loginIdValidations","withVerifyValidations","withSignValidations","withWaitForSessionValidations","withUpdateEmailValidations","withEnchantedLink","loginId","URI","loginOptions","user","waitForSession","pendingRef","pollingIntervalMs","timeoutMs","Math","max","normalizeWaitForSessionConfig","timeout","interval","setInterval","clearInterval","clearTimeout","setTimeout","errorDescription","errorCode","updateOptions","withStartValidations","withNextValidations","withFlow","flowId","options","conditionInteractionId","interactionId","input","version","executionId","stepId","withUpdatePhoneValidations","withMagicLink","delivery","OAuthProviders","withOauth","provider","redirectUrl","redirectURL","withOtp","withSaml","tenantIdOrEmail","withSignUpValidations","withUpdateValidations","withTotp","loginIdValidation","newPasswordValidation","withSendResetValidations","withUpdateValidation","withReplaceValidation","withPassword","password","newPassword","oldPassword","loginIdStringValidations","loginIdNonEmptyValidations","originValidations","withSignUpStartValidations","withSignUpOrInStartValidations","withSignInStartValidations","withUpdateStartValidations","withFinishValidations","withWebauthn","origin","name","transactionId","withJwtValidations","withOptionalTokenValidations","isStringOrUndefinedValidator","rules","createSdk","validatePathValue","withSdkConfigValidations","beforeRequestHooks","concat","afterRequestHooks","_b","req","allSettled","map","result","reason","withMultipleHooks","otp","magicLink","enchantedLink","oauth","saml","totp","webauthn","flow","refresh","logout","logoutAll","me","index","obj","paths","wrapper","sections","split","section","shift","currentRef","origFn"],"mappings":"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"}