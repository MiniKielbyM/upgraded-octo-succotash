import * as _descope_core_js_sdk from '@descope/core-js-sdk';
import _descope_core_js_sdk__default, { SdkResponse, ExchangeAccessKeyResponse } from '@descope/core-js-sdk';
export { DeliveryMethod, JWTResponse, OAuthProvider, ResponseData, SdkResponse } from '@descope/core-js-sdk';
import { JWTHeaderParameters, KeyLike } from 'jose';

/** Represents a tenant association for a User or Access Key. The tenantId is required to denote
 * which tenant the user or access key belongs to. The roleNames array is an optional list of
 * roles for the user or access key in this specific tenant.
 */
type AssociatedTenant = {
    tenantId: string;
    roleNames: string[];
};
/** The tenantId of a newly created tenant */
type CreateTenantResponse = {
    id: string;
};
/** An access key that can be used to access descope */
type AccessKey = {
    id: string;
    name: string;
    expiredTime: number;
    roleNames: string[];
    keyTenants?: AssociatedTenant[];
    status: string;
    createdTime: number;
    expiresTime: number;
    createdBy: string;
};
/** Access Key extended details including created key cleartext */
type CreatedAccessKeyResponse = {
    key: AccessKey;
    cleartext: string;
};
/** Represents a mapping between a set of groups of users and a role that will be assigned to them */
type RoleMapping = {
    groups: string[];
    roleName: string;
};
type RoleMappings = RoleMapping[];
/** Represents a mapping between Descope and IDP user attributes */
type AttributeMapping = {
    name?: string;
    email?: string;
    phoneNumber?: string;
    group?: string;
};
/** UpdateJWT response with a new JWT value with the added custom claims */
type UpdateJWTResponse = {
    jwt: string;
};
/** Represents a tenant in a project. It has an id, a name and an array of
 * self provisioning domains used to associate users with that tenant.
 */
type Tenant = {
    id: string;
    name: string;
    selfProvisioningDomains: string[];
};
/** Represents a permission in a project. It has a name and optionally a description.
 * It also has a flag indicating whether it is system default or not.
 */
type Permission = {
    name: string;
    description?: string;
    systemDefault: boolean;
};
/** Represents a role in a project. It has a name and optionally a description and
 * a list of permissions it grants.
 */
type Role = {
    name: string;
    description?: string;
    permissionNames: string[];
    createdTime: number;
};
/** Represents a group in a project. It has an id and display name and a list of group members. */
type Group = {
    id: string;
    display: string;
    members?: GroupMember[];
};
/** Represents a group member. It has loginId, userId and display. */
type GroupMember = {
    loginId: string;
    userId: string;
    display: string;
};
type Flow = {
    id: string;
    name: string;
    description?: string;
    dsl: any;
    disabled: boolean;
    etag?: string;
};
type FlowMetadata = {
    id: string;
    name: string;
    description?: string;
    disabled: boolean;
};
type Screen = {
    id: string;
    flowId: string;
    inputs?: any;
    interactions?: any;
    htmlTemplate: any;
};
type FlowsResponse = {
    flows: FlowMetadata[];
    total: number;
};
type FlowResponse = {
    flow: Flow;
    screens: Screen[];
};
type Theme = {
    id: string;
    cssTemplate?: any;
};
type ThemeResponse = {
    theme: Theme;
};
type GenerateOTPForTestResponse = {
    loginId: string;
    code: string;
};
type GenerateMagicLinkForTestResponse = {
    loginId: string;
    link: string;
};
type GenerateEnchantedLinkForTestResponse = {
    loginId: string;
    link: string;
    pendingRef: string;
};
type GenerateEmbeddedLinkResponse = {
    token: string;
};
type AttributesTypes = string | boolean | number;
type UserMapping = {
    name: string;
    email: string;
    username: string;
    phoneNumber: string;
    group: string;
};
type RoleItem = {
    id: string;
    name: string;
};
type GroupsMapping = {
    role: RoleItem;
    groups: string[];
};
type SSOSettingsResponse = {
    tenantId: string;
    idpEntityId: string;
    idpSSOUrl: string;
    idpCertificate: string;
    idpMetadataUrl: string;
    spEntityId: string;
    spACSUrl: string;
    spCertificate: string;
    userMapping: UserMapping;
    groupsMapping: GroupsMapping[];
    redirectUrl: string;
    domain: string;
};
type ProviderTokenResponse = {
    provider: string;
    providerUserId: string;
    accessToken: string;
    expiration: number;
    scopes: string[];
};
/**
 * Search options to filter which audit records we should retrieve.
 * All parameters are optional. `From` is currently limited to 30 days.
 */
type AuditSearchOptions = {
    userIds?: string[];
    actions?: string[];
    excludedActions?: string[];
    devices?: string[];
    methods?: string[];
    geos?: string[];
    remoteAddresses?: string[];
    loginIds?: string[];
    tenants?: string[];
    noTenants?: boolean;
    text?: string;
    from?: number;
    to?: number;
};
/** Audit record response from the audit trail. Occurred is in milliseconds. */
type AuditRecord = {
    projectId: string;
    userId: string;
    action: string;
    occurred: number;
    device: string;
    method: string;
    geo: string;
    remoteAddress: string;
    loginIds: string[];
    tenants: string[];
    data: Record<string, any>;
};
declare enum UserStatus {
    enabled = "enabled",
    disabled = "disabled",
    invited = "invited"
}

/** Parsed JWT token */
interface Token {
    sub?: string;
    exp?: number;
    iss?: string;
    [claim: string]: unknown;
}
/** All information regarding token including the raw JWT, parsed JWT and cookies */
interface AuthenticationInfo {
    jwt: string;
    token: Token;
    cookies?: string[];
}

/** Configuration arguments which include the Descope core SDK args and an optional management key */
type NodeSdkArgs = Parameters<typeof _descope_core_js_sdk__default>[0] & {
    managementKey?: string;
    publicKey?: string;
};
declare const nodeSdk: {
    ({ managementKey, publicKey, ...config }: NodeSdkArgs): {
        management: {
            user: {
                create: (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                createTestUser: (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                invite: (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                update: (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                delete: (loginId: string) => Promise<SdkResponse<never>>;
                deleteAllTestUsers: () => Promise<SdkResponse<never>>;
                load: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                loadByUserId: (userId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                searchAll: (tenantIds?: string[], roles?: string[], limit?: number, page?: number, testUsersOnly?: boolean, withTestUser?: boolean, customAttributes?: Record<string, AttributesTypes>, statuses?: UserStatus[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse[]>>;
                getProviderToken: (loginId: string, provider: string) => Promise<SdkResponse<ProviderTokenResponse>>;
                activate: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                deactivate: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateLoginId: (loginId: string, newLoginId?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateEmail: (loginId: string, email: string, isVerified: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updatePhone: (loginId: string, phone: string, isVerified: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateDisplayName: (loginId: string, displayName: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updatePicture: (loginId: string, picture: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateCustomAttribute: (loginId: string, attributeKey: string, attributeValue: AttributesTypes) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addTenant: (loginId: string, tenantId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeTenant: (loginId: string, tenantId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                generateOTPForTestUser: (deliveryMethod: "email" | "sms" | "whatsapp", loginId: string) => Promise<SdkResponse<GenerateOTPForTestResponse>>;
                generateMagicLinkForTestUser: (deliveryMethod: "email" | "sms" | "whatsapp", loginId: string, uri: string) => Promise<SdkResponse<GenerateMagicLinkForTestResponse>>;
                generateEnchantedLinkForTestUser: (loginId: string, uri: string) => Promise<SdkResponse<GenerateEnchantedLinkForTestResponse>>;
                generateEmbeddedLink: (loginId: string, customClaims?: Record<string, any>) => Promise<SdkResponse<GenerateEmbeddedLinkResponse>>;
                setPassword: (loginId: string, password: string) => Promise<SdkResponse<never>>;
                expirePassword: (loginId: string) => Promise<SdkResponse<never>>;
            };
            project: {
                updateName: (name: string) => Promise<SdkResponse<never>>;
            };
            accessKey: {
                create: (name: string, expireTime: number, roles?: string[], keyTenants?: AssociatedTenant[]) => Promise<SdkResponse<CreatedAccessKeyResponse>>;
                load: (id: string) => Promise<SdkResponse<AccessKey>>;
                searchAll: (tenantIds?: string[]) => Promise<SdkResponse<AccessKey[]>>;
                update: (id: string, name: string) => Promise<SdkResponse<AccessKey>>;
                deactivate: (id: string) => Promise<SdkResponse<never>>;
                activate: (id: string) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
            };
            tenant: {
                create: (name: string, selfProvisioningDomains?: string[]) => Promise<SdkResponse<CreateTenantResponse>>;
                createWithId: (id: string, name: string, selfProvisioningDomains?: string[]) => Promise<SdkResponse<never>>;
                update: (id: string, name: string, selfProvisioningDomains?: string[]) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
                load: (id: string) => Promise<SdkResponse<Tenant>>;
                loadAll: () => Promise<SdkResponse<Tenant[]>>;
            };
            sso: {
                getSettings: (tenantId: string) => Promise<SdkResponse<SSOSettingsResponse>>;
                deleteSettings: (tenantId: string) => Promise<SdkResponse<never>>;
                configureSettings: (tenantId: string, idpURL: string, idpCert: string, entityId: string, redirectURL: string, domain: string) => Promise<SdkResponse<never>>;
                configureMetadata: (tenantId: string, idpMetadataURL: string, redirectURL: string, domain: string) => Promise<SdkResponse<never>>;
                configureMapping: (tenantId: string, roleMappings?: RoleMappings, attributeMapping?: AttributeMapping) => Promise<SdkResponse<never>>;
            };
            jwt: {
                update: (jwt: string, customClaims?: Record<string, any>) => Promise<SdkResponse<UpdateJWTResponse>>;
            };
            permission: {
                create: (name: string, description?: string) => Promise<SdkResponse<never>>;
                update: (name: string, newName: string, description?: string) => Promise<SdkResponse<never>>;
                delete: (name: string) => Promise<SdkResponse<never>>;
                loadAll: () => Promise<SdkResponse<Permission[]>>;
            };
            role: {
                create: (name: string, description?: string, permissionNames?: string[]) => Promise<SdkResponse<never>>;
                update: (name: string, newName: string, description?: string, permissionNames?: string[]) => Promise<SdkResponse<never>>;
                delete: (name: string) => Promise<SdkResponse<never>>;
                loadAll: () => Promise<SdkResponse<Role[]>>;
            };
            group: {
                loadAllGroups: (tenantId: string) => Promise<SdkResponse<Group[]>>;
                loadAllGroupsForMember: (tenantId: string, userIds: string[], loginIds: string[]) => Promise<SdkResponse<Group[]>>;
                loadAllGroupMembers: (tenantId: string, groupId: string) => Promise<SdkResponse<Group[]>>;
            };
            flow: {
                list: () => Promise<SdkResponse<FlowsResponse>>;
                export: (flowId: string) => Promise<SdkResponse<FlowResponse>>;
                import: (flowId: string, flow: Flow, screens?: Screen[]) => Promise<SdkResponse<FlowResponse>>;
            };
            theme: {
                export: () => Promise<SdkResponse<ThemeResponse>>;
                import: (theme: Theme) => Promise<SdkResponse<ThemeResponse>>;
            };
            audit: {
                search: (searchOptions: AuditSearchOptions) => Promise<SdkResponse<AuditRecord[]>>;
            };
        };
        getKey: (header: JWTHeaderParameters) => Promise<KeyLike | Uint8Array>;
        validateJwt: (jwt: string) => Promise<AuthenticationInfo>;
        validateSession: (sessionToken: string) => Promise<AuthenticationInfo>;
        refreshSession: (refreshToken: string) => Promise<AuthenticationInfo>;
        validateAndRefreshSession: (sessionToken?: string, refreshToken?: string) => Promise<AuthenticationInfo>;
        exchangeAccessKey: (accessKey: string) => Promise<AuthenticationInfo>;
        validatePermissions: (authInfo: AuthenticationInfo, permissions: string[]) => boolean;
        validateTenantPermissions: (authInfo: AuthenticationInfo, tenant: string, permissions: string[]) => boolean;
        validateRoles: (authInfo: AuthenticationInfo, roles: string[]) => boolean;
        validateTenantRoles: (authInfo: AuthenticationInfo, tenant: string, roles: string[]) => boolean;
        accessKey: {
            exchange: (accessKey: string) => Promise<SdkResponse<ExchangeAccessKeyResponse>>;
        };
        otp: {
            verify: {
                sms: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                whatsapp: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                email: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signIn: {
                sms: (loginId: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUp: {
                sms: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUpOrIn: {
                sms: (loginId: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            update: {
                email: <T extends boolean>(loginId: string, email: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T;
                    onMergeUseExisting?: T extends true ? boolean : never;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
                phone: {
                    sms: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    whatsapp: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                };
            };
        };
        magicLink: {
            verify: (token: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            signIn: {
                sms: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUp: {
                sms: (loginId: string, uri: string, user?: {
                    email?: string;
                    name?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, uri: string, user?: {
                    email?: string;
                    name?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, uri: string, user?: {
                    email?: string;
                    name?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUpOrIn: {
                sms: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            update: {
                email: <T_2 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T_2;
                    onMergeUseExisting?: T_2 extends true ? boolean : never;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
                phone: {
                    sms: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    whatsapp: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                };
            };
        };
        enchantedLink: {
            verify: (token: string) => Promise<SdkResponse<never>>;
            signIn: (loginId: string, uri: string) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            signUpOrIn: (loginId: string, uri: string) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse>>;
            signUp: (loginId: string, uri: string, user?: {
                email?: string;
                name?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            waitForSession: (pendingRef: string, config?: {
                pollingIntervalMs: number;
                timeoutMs: number;
            }) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            update: {
                email: <T_4 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T_4;
                    onMergeUseExisting?: T_4 extends true ? boolean : never;
                }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse>>;
            };
        };
        oauth: {
            start: {
                facebook: <B extends {
                    redirect: boolean;
                }>(redirectURL?: string, config?: B) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                github: <B_1 extends {
                    redirect: boolean;
                }>(redirectURL?: string, config?: B_1) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                google: <B_2 extends {
                    redirect: boolean;
                }>(redirectURL?: string, config?: B_2) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                microsoft: <B_3 extends {
                    redirect: boolean;
                }>(redirectURL?: string, config?: B_3) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                gitlab: <B_4 extends {
                    redirect: boolean;
                }>(redirectURL?: string, config?: B_4) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                apple: <B_5 extends {
                    redirect: boolean;
                }>(redirectURL?: string, config?: B_5) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                discord: <B_6 extends {
                    redirect: boolean;
                }>(redirectURL?: string, config?: B_6) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                linkedin: <B_7 extends {
                    redirect: boolean;
                }>(redirectURL?: string, config?: B_7) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
            };
            exchange: (code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
        };
        saml: {
            start: (tenantIdOrEmail: string, redirectUrl?: string, loginOptions?: {
                stepup?: boolean;
                mfa?: boolean;
                customClaims?: Record<string, any>;
            }, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
            exchange: (code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
        };
        totp: {
            signUp: (loginId: string, user?: {
                email?: string;
                name?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.TOTPResponse>>;
            verify: (loginId: string, code: string, loginOptions?: {
                stepup?: boolean;
                mfa?: boolean;
                customClaims?: Record<string, any>;
            }, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            update: (loginId: string, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.TOTPResponse>>;
        };
        webauthn: {
            signUp: {
                start: (loginId: string, origin: string, name: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signIn: {
                start: (loginId: string, origin: string, loginOptions?: {
                    stepup?: boolean;
                    mfa?: boolean;
                    customClaims?: Record<string, any>;
                }, token?: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signUpOrIn: {
                start: (loginId: string, origin: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
            };
            update: {
                start: (loginId: string, origin: string, token: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>;
            };
        };
        password: {
            signUp: (loginId: string, password: string, user?: {
                email?: string;
                name?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            signIn: (loginId: string, password: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            sendReset: (loginId: string, redirectUrl?: string) => Promise<SdkResponse<{
                resetMethod: string;
                pendingRef?: string;
                linkId?: string;
                maskedEmail: string;
            }>>;
            update: (loginId: string, newPassword: string, token?: string) => Promise<SdkResponse<never>>;
            replace: (loginId: string, oldPassword: string, newPassword: string) => Promise<SdkResponse<never>>;
            policy: () => Promise<SdkResponse<{
                minLength: number;
                lowercase: boolean;
                uppercase: boolean;
                number: boolean;
                nonAlphanumeric: boolean;
            }>>;
        };
        flow: {
            start: (flowId: string, options?: {
                redirectUrl?: string;
                tenant?: string;
                deviceInfo?: {
                    webAuthnSupport?: boolean;
                };
                lastAuth?: {
                    authMethod?: "otp" | "oauth" | "saml" | "totp" | "webauthn" | "magiclink" | "enchantedlink";
                    oauthProvider?: string;
                    name?: string;
                    loginId?: string;
                };
                redirectAuth?: {
                    callbackUrl: string;
                    codeChallenge: string;
                };
                oidcIdpStateId?: string;
            }, conditionInteractionId?: string, interactionId?: string, input?: {
                [x: string]: string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | any)[])[])[])[])[])[])[])[])[])[])[];
            }, version?: number) => Promise<SdkResponse<_descope_core_js_sdk.FlowResponse>>;
            next: (executionId: string, stepId: string, interactionId: string, input?: {
                [x: string]: string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | any)[])[])[])[])[])[])[])[])[])[])[];
            }, version?: number) => Promise<SdkResponse<_descope_core_js_sdk.FlowResponse>>;
        };
        refresh: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
            refreshJwt?: string;
            cookies?: string[];
        }>>;
        logout: (token?: string) => Promise<SdkResponse<never>>;
        logoutAll: (token?: string) => Promise<SdkResponse<never>>;
        me: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
        isJwtExpired: (token: string) => boolean;
        getTenants: (token: string) => string[];
        getJwtPermissions: (token: string, tenant?: string) => string[];
        getJwtRoles: (token: string, tenant?: string) => string[];
        httpClient: {
            get: (path: string, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            post: (path: string, body?: any, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            put: (path: string, body?: any, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            delete: (path: string, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            hooks?: {
                beforeRequest?: (config: _descope_core_js_sdk.RequestConfig) => _descope_core_js_sdk.RequestConfig;
                afterRequest?: (req: _descope_core_js_sdk.RequestConfig, res: Response) => void | Promise<void>;
            };
        };
    };
    /** Descope SDK client with delivery methods enum.
     *
     * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}
     * @example Usage
     *
     * ```js
     * import descopeSdk from '@descope/node-sdk';
     *
     * const myProjectId = 'xxx';
     * const sdk = descopeSdk({ projectId: myProjectId });
     *
     * const userLoginId = 'loginId';
     * sdk.otp.signIn.email(userLoginId);
     * const jwtResponse = sdk.otp.verify.email(userLoginId, codeFromEmail);
     * ```
     */
    RefreshTokenCookieName: string;
    SessionTokenCookieName: string;
};

export { AuthenticationInfo, nodeSdk as default };
