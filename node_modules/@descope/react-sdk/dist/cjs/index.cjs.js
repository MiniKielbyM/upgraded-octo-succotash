"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react"),t=require("@descope/web-js-sdk");function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function s(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var s=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var o=r(e),n=r(t);const u=o.default.createContext(void 0),i=e=>(...t)=>{if(!e)throw Error("You can only use this function after sdk initialization. Make sure to supply 'projectId' to <AuthProvider /> component");return e(...t)},c=e=>(...t)=>{let r;try{r=e(...t)}catch(e){console.error(e)}return r},a={"x-descope-sdk-name":"react","x-descope-sdk-version":"1.0.12"},l="undefined"!=typeof window;let d;const f=e=>{const t=n.default({...e,persistTokens:l,autoRefresh:l});return d=t,t};d=f({projectId:"temp pid"});const p=()=>l?d?.getSessionToken():(console.warn("Get session token is not supported in SSR"),""),h=()=>l?d?.getRefreshToken():(console.warn("Get refresh token is not supported in SSR"),""),m=c(((e=p(),t)=>d?.getJwtPermissions(e,t))),g=c(((e=p(),t)=>d?.getJwtRoles(e,t)));const k=e.lazy((async()=>((await Promise.resolve().then((function(){return s(require("@descope/web-component"))}))).default.sdkConfigOverrides={baseHeaders:a},{default:({projectId:e,flowId:t,baseUrl:r,innerRef:s,tenant:n,theme:u,locale:i,debug:c,telemetryKey:a,redirectUrl:l,autoFocus:d})=>o.default.createElement("descope-wc",{"project-id":e,"flow-id":t,"base-url":r,ref:s,tenant:n,theme:u,locale:i,debug:c,telemetryKey:a,"redirect-url":l,"auto-focus":d})}))),w=o.default.forwardRef((({flowId:t,onSuccess:r,onError:s,logger:n,tenant:i,theme:c,locale:a,debug:l,telemetryKey:d,redirectUrl:f,autoFocus:p,errorTransformer:h},m)=>{const[g,w]=e.useState(null);e.useImperativeHandle(m,(()=>g));const{projectId:b,baseUrl:y,sdk:S}=o.default.useContext(u),E=e.useCallback((async e=>{await S.httpClient.hooks.afterRequest({},new Response(JSON.stringify(e.detail))),r&&r(e)}),[r]);return e.useEffect((()=>{const e=g;return e?.addEventListener("success",E),s&&e?.addEventListener("error",s),()=>{s&&e?.removeEventListener("error",s),e?.removeEventListener("success",E)}}),[g,s,E]),e.useEffect((()=>{g&&(g.errorTransformer=h)}),[g,h]),e.useEffect((()=>{g&&n&&(g.logger=n)}),[g,n]),o.default.createElement("form",null,o.default.createElement(e.Suspense,{fallback:null},o.default.createElement(k,{projectId:b,flowId:t,baseUrl:y,innerRef:w,tenant:i,theme:c,locale:a,debug:l,telemetryKey:d,redirectUrl:f,autoFocus:p})))}));var b=()=>{const t=e.useContext(u);if(!t)throw Error("You can only use this hook in the context of <AuthProvider />");return t};const y=e=>`You can only use this ${e} after sdk initialization. Make sure to supply 'projectId' to <AuthProvider /> component`,S={get(e,t){if("object"==typeof e[t]&&null!==e[t])return new Proxy(e[t],S);if("function"==typeof e[t])return()=>{throw Error(y("function"))};throw Error(y("attribute"))}};exports.AuthProvider=({projectId:t,baseUrl:r="",sessionTokenViaCookie:s=!1,children:n})=>{const[c,l]=e.useState(),[d,p]=e.useState(),[h,m]=e.useState(!1),[g,k]=e.useState(!1),w=(({projectId:t,baseUrl:r,sessionTokenViaCookie:s})=>e.useMemo((()=>{if(t)return f({projectId:t,baseUrl:r,sessionTokenViaCookie:s,baseHeaders:a,persistToken:!0,autoRefresh:!0})}),[t,r,s]))({projectId:t,baseUrl:r,sessionTokenViaCookie:s});e.useEffect((()=>{if(w){const e=w.onSessionTokenChange(p),t=w.onUserChange(l);return()=>{e(),t()}}}),[w]);const b=e.useRef(!1),y=e.useCallback((()=>{b.current||(b.current=!0,k(!0),i(w?.refresh)().then((()=>{k(!1)})))}),[w]),S=e.useCallback((()=>{m(!0),i(w.me)().then((()=>{m(!1)}))}),[w]),E=e.useMemo((()=>({fetchUser:S,user:c,isUserLoading:h,fetchSession:y,session:d,isSessionLoading:g,isSessionFetched:b.current,projectId:t,baseUrl:r,setUser:l,setSession:p,sdk:w})),[S,c,h,y,d,g,b.current,t,r,l,p,w]);return o.default.createElement(u.Provider,{value:E},n)},exports.Descope=w,exports.SignInFlow=e=>o.default.createElement(w,{...e,flowId:"sign-in"}),exports.SignUpFlow=e=>o.default.createElement(w,{...e,flowId:"sign-up"}),exports.SignUpOrInFlow=e=>o.default.createElement(w,{...e,flowId:"sign-up-or-in"}),exports.getJwtPermissions=m,exports.getJwtRoles=g,exports.getRefreshToken=h,exports.getSessionToken=p,exports.refresh=(e=h())=>d?.refresh(e),exports.useDescope=()=>{const{sdk:t}=b();return e.useMemo((()=>t||new Proxy(f({projectId:"dummy"}),S)),[t])},exports.useSession=()=>{const{session:t,isSessionLoading:r,fetchSession:s,isSessionFetched:o}=b(),n=e.useRef(r);return e.useMemo((()=>{n.current=r}),[r]),e.useMemo((()=>{o||(n.current=!0)}),[o]),e.useEffect((()=>{t||r||s()}),[s]),{isSessionLoading:n.current,sessionToken:t,isAuthenticated:!!t}},exports.useUser=()=>{const{user:t,fetchUser:r,isUserLoading:s,session:o}=b(),[n,u]=e.useState(!1),i=e.useRef(s),c=e.useMemo((()=>!t&&!s&&o&&!n),[r,o,n]);return e.useMemo((()=>{i.current=s}),[s]),e.useMemo((()=>{c&&(i.current=!0)}),[c]),e.useEffect((()=>{c&&(u(!0),r())}),[c]),{isUserLoading:i.current,user:t}};
//# sourceMappingURL=index.cjs.js.map
