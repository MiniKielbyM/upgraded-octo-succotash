{"version":3,"file":"index.esm.js","sources":["../src/hooks/Context.ts","../src/utils.ts","../src/constants.ts","../src/sdk.ts","../src/components/AuthProvider/AuthProvider.tsx","../src/components/AuthProvider/useSdk.ts","../src/components/Descope.tsx","../src/components/DefaultFlows.tsx","../src/hooks/useContext.ts","../src/hooks/useDescope.ts","../src/hooks/useSession.ts","../src/hooks/useUser.ts"],"sourcesContent":["import React from 'react';\nimport { IContext } from '../types';\n\nconst Context = React.createContext<IContext>(undefined);\n\nexport default Context;\n","/**\n * Wrap a function with a validation that it exists\n * @param fn The function to wrap with the validation\n * @throws if function does not exist, an error with the relevant message will be thrown\n */\nexport const withValidation =\n\t<T extends Array<any>, U>(fn: (...args: T) => U) =>\n\t(...args: T): U => {\n\t\tif (!fn) {\n\t\t\tthrow Error(\n\t\t\t\t`You can only use this function after sdk initialization. Make sure to supply 'projectId' to <AuthProvider /> component`\n\t\t\t);\n\t\t}\n\t\treturn fn(...args);\n\t};\n\nexport const wrapInTry =\n\t<T extends Array<any>, U>(fn: (...args: T) => U) =>\n\t(...args: T): U => {\n\t\tlet res: U;\n\t\ttry {\n\t\t\tres = fn(...args);\n\t\t} catch (err) {\n\t\t\tconsole.error(err); // eslint-disable-line no-console\n\t\t}\n\t\treturn res;\n\t};\n","declare const BUILD_VERSION: string;\n\n// eslint-disable-next-line import/prefer-default-export\nexport const baseHeaders = {\n\t'x-descope-sdk-name': 'react',\n\t'x-descope-sdk-version': BUILD_VERSION\n};\n\n// This sdk can be used in SSR apps\nexport const IS_BROWSER = typeof window !== 'undefined';\n","import createSdk from '@descope/web-js-sdk';\nimport { IS_BROWSER } from './constants';\nimport { wrapInTry } from './utils';\n\ntype Sdk = ReturnType<typeof createSdkWrapper>;\nlet sdkInstance: Sdk;\n\nconst createSdkWrapper = <P extends Parameters<typeof createSdk>[0]>(\n\tconfig: P\n) => {\n\tconst sdk = createSdk({\n\t\t...config,\n\t\tpersistTokens: IS_BROWSER as true,\n\t\tautoRefresh: IS_BROWSER as true\n\t});\n\tsdkInstance = sdk;\n\n\treturn sdk;\n};\n\n/**\n * We want to make sure the getSessionToken fn is used only when persistTokens is on\n *\n * So we are keeping the SDK init in a single place,\n * and we are creating a temp instance in order to export the getSessionToken\n * even before the SDK was init\n */\nsdkInstance = createSdkWrapper({ projectId: 'temp pid' });\n\nexport const getSessionToken = () => {\n\tif (IS_BROWSER) {\n\t\treturn sdkInstance?.getSessionToken();\n\t}\n\n\t// eslint-disable-next-line no-console\n\tconsole.warn('Get session token is not supported in SSR');\n\treturn '';\n};\n\nexport const getRefreshToken = () => {\n\tif (IS_BROWSER) {\n\t\treturn sdkInstance?.getRefreshToken();\n\t}\n\t// eslint-disable-next-line no-console\n\tconsole.warn('Get refresh token is not supported in SSR');\n\treturn '';\n};\n\nexport const getJwtPermissions = wrapInTry(\n\t(token = getSessionToken(), tenant?: string) =>\n\t\tsdkInstance?.getJwtPermissions(token, tenant)\n);\n\nexport const getJwtRoles = wrapInTry(\n\t(token = getSessionToken(), tenant?: string) =>\n\t\tsdkInstance?.getJwtRoles(token, tenant)\n);\n\nexport const refresh = (token = getRefreshToken()) =>\n\tsdkInstance?.refresh(token);\n\nexport default createSdkWrapper;\n","import React, {\n\tFC,\n\tuseCallback,\n\tuseEffect,\n\tuseMemo,\n\tuseRef,\n\tuseState\n} from 'react';\nimport Context from '../../hooks/Context';\nimport { IContext, User } from '../../types';\nimport { withValidation } from '../../utils';\nimport useSdk from './useSdk';\n\ninterface IAuthProviderProps {\n\tprojectId: string;\n\tbaseUrl?: string;\n\t// If true, session token (jwt) will be stored on cookie. Otherwise, the session token will be\n\t// stored on local storage and can accessed with getSessionToken function\n\t// Use this option if session token will stay small (less than 1k)\n\t// NOTE: Session token can grow, especially in cases of using authorization, or adding custom claims\n\tsessionTokenViaCookie?: boolean;\n\tchildren?: JSX.Element;\n}\n\nconst AuthProvider: FC<IAuthProviderProps> = ({\n\tprojectId,\n\tbaseUrl = '',\n\tsessionTokenViaCookie = false,\n\tchildren = undefined\n}) => {\n\tconst [user, setUser] = useState<User>();\n\tconst [session, setSession] = useState<string>();\n\n\tconst [isUserLoading, setIsUserLoading] = useState(false);\n\tconst [isSessionLoading, setIsSessionLoading] = useState(false);\n\n\tconst sdk = useSdk({ projectId, baseUrl, sessionTokenViaCookie });\n\n\tuseEffect(() => {\n\t\tif (sdk) {\n\t\t\tconst unsubscribeSessionToken = sdk.onSessionTokenChange(setSession);\n\t\t\tconst unsubscribeUser = sdk.onUserChange(setUser);\n\n\t\t\treturn () => {\n\t\t\t\tunsubscribeSessionToken();\n\t\t\t\tunsubscribeUser();\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t}, [sdk]);\n\n\tconst isSessionFetched = useRef(false);\n\n\tconst fetchSession = useCallback(() => {\n\t\t// We want that the session will fetched only once\n\t\tif (isSessionFetched.current) return;\n\t\tisSessionFetched.current = true;\n\n\t\tsetIsSessionLoading(true);\n\t\twithValidation(sdk?.refresh)().then(() => {\n\t\t\tsetIsSessionLoading(false);\n\t\t});\n\t}, [sdk]);\n\n\tconst fetchUser = useCallback(() => {\n\t\tsetIsUserLoading(true);\n\t\twithValidation(sdk.me)().then(() => {\n\t\t\tsetIsUserLoading(false);\n\t\t});\n\t}, [sdk]);\n\n\tconst value = useMemo<IContext>(\n\t\t() => ({\n\t\t\tfetchUser,\n\t\t\tuser,\n\t\t\tisUserLoading,\n\t\t\tfetchSession,\n\t\t\tsession,\n\t\t\tisSessionLoading,\n\t\t\tisSessionFetched: isSessionFetched.current,\n\t\t\tprojectId,\n\t\t\tbaseUrl,\n\t\t\tsetUser,\n\t\t\tsetSession,\n\t\t\tsdk\n\t\t}),\n\t\t[\n\t\t\tfetchUser,\n\t\t\tuser,\n\t\t\tisUserLoading,\n\t\t\tfetchSession,\n\t\t\tsession,\n\t\t\tisSessionLoading,\n\t\t\tisSessionFetched.current,\n\t\t\tprojectId,\n\t\t\tbaseUrl,\n\t\t\tsetUser,\n\t\t\tsetSession,\n\t\t\tsdk\n\t\t]\n\t);\n\treturn <Context.Provider value={value}>{children}</Context.Provider>;\n};\n\nexport default AuthProvider;\n","import { useMemo } from 'react';\nimport { baseHeaders } from '../../constants';\nimport createSdk from '../../sdk';\n\ntype Config = Pick<\n\tParameters<typeof createSdk>[0],\n\t'projectId' | 'baseUrl' | 'sessionTokenViaCookie'\n>;\n\nexport default ({\n\tprojectId,\n\tbaseUrl,\n\tsessionTokenViaCookie\n}: Config): ReturnType<typeof createSdk> =>\n\tuseMemo(() => {\n\t\tif (!projectId) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn createSdk({\n\t\t\tprojectId,\n\t\t\tbaseUrl,\n\t\t\tsessionTokenViaCookie,\n\t\t\tbaseHeaders,\n\t\t\tpersistToken: true,\n\t\t\tautoRefresh: true\n\t\t});\n\t}, [projectId, baseUrl, sessionTokenViaCookie]);\n","import React, {\n\tlazy,\n\tSuspense,\n\tuseCallback,\n\tuseEffect,\n\tuseImperativeHandle,\n\tuseState\n} from 'react';\nimport { baseHeaders } from '../constants';\nimport Context from '../hooks/Context';\nimport { DescopeProps } from '../types';\n\n// web-component code uses browser API, but can be used in SSR apps, hence the lazy loading\nconst DescopeWC = lazy(async () => {\n\tconst module = await import('@descope/web-component');\n\t// we want to override the web-component base headers so we can tell that is was used via the React SDK\n\tmodule.default.sdkConfigOverrides = { baseHeaders };\n\n\treturn {\n\t\tdefault: ({\n\t\t\tprojectId,\n\t\t\tflowId,\n\t\t\tbaseUrl,\n\t\t\tinnerRef,\n\t\t\ttenant,\n\t\t\ttheme,\n\t\t\tlocale,\n\t\t\tdebug,\n\t\t\ttelemetryKey,\n\t\t\tredirectUrl,\n\t\t\tautoFocus\n\t\t}) => (\n\t\t\t<descope-wc\n\t\t\t\tproject-id={projectId}\n\t\t\t\tflow-id={flowId}\n\t\t\t\tbase-url={baseUrl}\n\t\t\t\tref={innerRef}\n\t\t\t\ttenant={tenant}\n\t\t\t\ttheme={theme}\n\t\t\t\tlocale={locale}\n\t\t\t\tdebug={debug}\n\t\t\t\ttelemetryKey={telemetryKey}\n\t\t\t\tredirect-url={redirectUrl}\n\t\t\t\tauto-focus={autoFocus}\n\t\t\t/>\n\t\t)\n\t};\n});\n\nconst Descope = React.forwardRef<HTMLElement, DescopeProps>(\n\t(\n\t\t{\n\t\t\tflowId,\n\t\t\tonSuccess,\n\t\t\tonError,\n\t\t\tlogger,\n\t\t\ttenant,\n\t\t\ttheme,\n\t\t\tlocale,\n\t\t\tdebug,\n\t\t\ttelemetryKey,\n\t\t\tredirectUrl,\n\t\t\tautoFocus,\n\t\t\terrorTransformer\n\t\t},\n\t\tref\n\t) => {\n\t\tconst [innerRef, setInnerRef] = useState(null);\n\n\t\tuseImperativeHandle(ref, () => innerRef);\n\n\t\tconst { projectId, baseUrl, sdk } = React.useContext(Context);\n\n\t\tconst handleSuccess = useCallback(\n\t\t\tasync (e: CustomEvent) => {\n\t\t\t\t// In order to make sure all the after-hooks are running with the success response\n\t\t\t\t// we are generating a fake response with the success data and calling the http client after hook fn with it\n\t\t\t\tawait sdk.httpClient.hooks.afterRequest(\n\t\t\t\t\t{} as any,\n\t\t\t\t\tnew Response(JSON.stringify(e.detail))\n\t\t\t\t);\n\t\t\t\tif (onSuccess) {\n\t\t\t\t\tonSuccess(e);\n\t\t\t\t}\n\t\t\t},\n\t\t\t[onSuccess]\n\t\t);\n\n\t\tuseEffect(() => {\n\t\t\tconst ele = innerRef;\n\t\t\tele?.addEventListener('success', handleSuccess);\n\t\t\tif (onError) ele?.addEventListener('error', onError);\n\n\t\t\treturn () => {\n\t\t\t\tif (onError) ele?.removeEventListener('error', onError);\n\n\t\t\t\tele?.removeEventListener('success', handleSuccess);\n\t\t\t};\n\t\t}, [innerRef, onError, handleSuccess]);\n\n\t\tuseEffect(() => {\n\t\t\tif (innerRef) {\n\t\t\t\tinnerRef.errorTransformer = errorTransformer;\n\t\t\t}\n\t\t}, [innerRef, errorTransformer]);\n\n\t\tuseEffect(() => {\n\t\t\tif (innerRef && logger) {\n\t\t\t\tinnerRef.logger = logger;\n\t\t\t}\n\t\t}, [innerRef, logger]);\n\n\t\treturn (\n\t\t\t/**\n\t\t\t * in order to avoid redundant remounting of the WC, we are wrapping it with a form element\n\t\t\t * this workaround is done in order to support webauthn passkeys\n\t\t\t * it can be removed once this issue will be solved\n\t\t\t * https://bugs.chromium.org/p/chromium/issues/detail?id=1404106#c2\n\t\t\t */\n\t\t\t<form>\n\t\t\t\t<Suspense fallback={null}>\n\t\t\t\t\t<DescopeWC\n\t\t\t\t\t\tprojectId={projectId}\n\t\t\t\t\t\tflowId={flowId}\n\t\t\t\t\t\tbaseUrl={baseUrl}\n\t\t\t\t\t\tinnerRef={setInnerRef}\n\t\t\t\t\t\ttenant={tenant}\n\t\t\t\t\t\ttheme={theme}\n\t\t\t\t\t\tlocale={locale}\n\t\t\t\t\t\tdebug={debug}\n\t\t\t\t\t\ttelemetryKey={telemetryKey}\n\t\t\t\t\t\tredirectUrl={redirectUrl}\n\t\t\t\t\t\tautoFocus={autoFocus}\n\t\t\t\t\t/>\n\t\t\t\t</Suspense>\n\t\t\t</form>\n\t\t);\n\t}\n);\n\nexport default Descope;\n","import React from 'react';\nimport { DefaultFlowProps } from '../types';\nimport Descope from './Descope';\n\nexport const SignInFlow = (props: DefaultFlowProps) => (\n\t<Descope {...props} flowId=\"sign-in\" />\n);\n\nexport const SignUpFlow = (props: DefaultFlowProps) => (\n\t<Descope {...props} flowId=\"sign-up\" />\n);\n\nexport const SignUpOrInFlow = (props: DefaultFlowProps) => (\n\t<Descope {...props} flowId=\"sign-up-or-in\" />\n);\n","import { useContext } from 'react';\nimport Context from './Context';\n\nexport default () => {\n\tconst ctx = useContext(Context);\n\tif (!ctx) {\n\t\tthrow Error(\n\t\t\t`You can only use this hook in the context of <AuthProvider />`\n\t\t);\n\t}\n\n\treturn ctx;\n};\n","import { useMemo } from 'react';\nimport { Sdk } from '../types';\nimport useContext from './useContext';\nimport createSdk from '../sdk';\n\nconst generateErrorMsg = (entryType: string) =>\n\t`You can only use this ${entryType} after sdk initialization. Make sure to supply 'projectId' to <AuthProvider /> component`;\n\n// handler which throw an error for every SDK function\nconst proxyThrowHandler = {\n\t// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\n\tget(target: Record<string, any>, key: string) {\n\t\tif (typeof target[key] === 'object' && target[key] !== null) {\n\t\t\treturn new Proxy(target[key], proxyThrowHandler);\n\t\t}\n\n\t\tif (typeof target[key] === 'function') {\n\t\t\treturn () => {\n\t\t\t\tthrow Error(generateErrorMsg('function'));\n\t\t\t};\n\t\t}\n\n\t\tthrow Error(generateErrorMsg('attribute'));\n\t}\n};\n\nconst useDescope = (): Sdk => {\n\tconst { sdk } = useContext();\n\n\treturn useMemo(() => {\n\t\tif (!sdk) {\n\t\t\t// In case the SDK is not initialized, we want to throw an error when the SDK functions are called\n\t\t\treturn new Proxy(\n\t\t\t\tcreateSdk({ projectId: 'dummy' }),\n\t\t\t\tproxyThrowHandler\n\t\t\t) as Sdk;\n\t\t}\n\n\t\treturn sdk;\n\t}, [sdk]);\n};\n\nexport default useDescope;\n","import { useEffect, useMemo, useRef } from 'react';\nimport useContext from './useContext';\n\nconst useSession = () => {\n\tconst { session, isSessionLoading, fetchSession, isSessionFetched } =\n\t\tuseContext();\n\n\t// when session should be received, we want the return value of \"isSessionLoading\" to be true starting from the first call\n\t// (and not only when receiving an update from the context)\n\tconst isLoading = useRef(isSessionLoading);\n\n\t// we want this to happen before returning a value so we are using \"useMemo\" and not \"useEffect\"\n\tuseMemo(() => {\n\t\tisLoading.current = isSessionLoading;\n\t}, [isSessionLoading]);\n\n\t// we want this to happen before returning a value so we are using \"useMemo\" and not \"useEffect\"\n\tuseMemo(() => {\n\t\tif (!isSessionFetched) {\n\t\t\tisLoading.current = true;\n\t\t}\n\t}, [isSessionFetched]);\n\n\tuseEffect(() => {\n\t\tif (!session && !isSessionLoading) {\n\t\t\tfetchSession();\n\t\t}\n\t}, [fetchSession]);\n\n\treturn {\n\t\tisSessionLoading: isLoading.current,\n\t\tsessionToken: session,\n\t\tisAuthenticated: !!session\n\t};\n};\n\nexport default useSession;\n","import { useEffect, useMemo, useRef, useState } from 'react';\nimport useContext from './useContext';\n\nconst useUser = () => {\n\tconst { user, fetchUser, isUserLoading, session } = useContext();\n\tconst [isInit, setIsInit] = useState(false); // we want to get the user only in the first time we got a session\n\n\t// when session should be received, we want the return value of \"isUserLoading\" to be true starting from the first call\n\t// (and not only when receiving an update from the context)\n\tconst isLoading = useRef(isUserLoading);\n\n\tconst shouldFetchUser = useMemo(\n\t\t() => !user && !isUserLoading && session && !isInit,\n\t\t[fetchUser, session, isInit]\n\t);\n\n\t// we want this to happen before returning a value so we are using \"useMemo\" and not \"useEffect\"\n\tuseMemo(() => {\n\t\tisLoading.current = isUserLoading;\n\t}, [isUserLoading]);\n\n\t// we want this to happen before returning a value so we are using \"useMemo\" and not \"useEffect\"\n\tuseMemo(() => {\n\t\tif (shouldFetchUser) {\n\t\t\tisLoading.current = true;\n\t\t}\n\t}, [shouldFetchUser]);\n\n\tuseEffect(() => {\n\t\tif (shouldFetchUser) {\n\t\t\tsetIsInit(true);\n\t\t\tfetchUser();\n\t\t}\n\t}, [shouldFetchUser]);\n\n\treturn { isUserLoading: isLoading.current, user };\n};\n\nexport default useUser;\n"],"names":["Context","React","createContext","undefined","withValidation","fn","args","Error","wrapInTry","res","err","console","error","baseHeaders","IS_BROWSER","window","sdkInstance","createSdkWrapper","config","sdk","createSdk","persistTokens","autoRefresh","projectId","getSessionToken","warn","getRefreshToken","getJwtPermissions","token","tenant","getJwtRoles","refresh","AuthProvider","baseUrl","sessionTokenViaCookie","children","user","setUser","useState","session","setSession","isUserLoading","setIsUserLoading","isSessionLoading","setIsSessionLoading","useMemo","persistToken","useSdk","useEffect","unsubscribeSessionToken","onSessionTokenChange","unsubscribeUser","onUserChange","isSessionFetched","useRef","fetchSession","useCallback","current","then","fetchUser","me","value","createElement","Provider","DescopeWC","lazy","async","import","default","sdkConfigOverrides","flowId","innerRef","theme","locale","debug","telemetryKey","redirectUrl","autoFocus","ref","Descope","forwardRef","onSuccess","onError","logger","errorTransformer","setInnerRef","useImperativeHandle","useContext","handleSuccess","e","httpClient","hooks","afterRequest","Response","JSON","stringify","detail","ele","addEventListener","removeEventListener","Suspense","fallback","SignInFlow","props","SignUpFlow","SignUpOrInFlow","ctx","generateErrorMsg","entryType","proxyThrowHandler","get","target","key","Proxy","useDescope","useSession","isLoading","sessionToken","isAuthenticated","useUser","isInit","setIsInit","shouldFetchUser"],"mappings":"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"}