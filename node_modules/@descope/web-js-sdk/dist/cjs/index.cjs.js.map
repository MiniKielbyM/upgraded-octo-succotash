{"version":3,"file":"index.cjs.js","sources":["../../src/enhancers/helpers/index.ts","../../src/enhancers/helpers/logger.ts","../../src/constants.ts","../../src/enhancers/withFingerprint/constants.ts","../../src/enhancers/withFingerprint/helpers.ts","../../src/enhancers/withFingerprint/index.ts","../../src/enhancers/withLastLoggedInUser/constants.ts","../../src/enhancers/withLastLoggedInUser/helpers.ts","../../src/enhancers/withLastLoggedInUser/index.ts","../../src/enhancers/withNotifications/helpers.ts","../../src/enhancers/withNotifications/index.ts","../../src/enhancers/withPersistTokens/constants.ts","../../src/enhancers/withPersistTokens/helpers.ts","../../src/enhancers/withPersistTokens/index.ts","../../src/sdk/webauthn.ts","../../src/sdk/flow.ts","../../src/sdk/index.ts","../../src/index.ts","../../src/enhancers/helpers/compose.ts","../../src/enhancers/withAutoRefresh/index.ts","../../src/enhancers/withAutoRefresh/helpers.ts","../../src/enhancers/withAnalytics.ts"],"sourcesContent":["import { JWTResponse, UserResponse } from '@descope/core-js-sdk';\nimport { CoreSdkConfig } from '../../types';\n\n/**\n * Add hooks to an existing core-sdk config\n */\nexport const addHooks = <Config extends CoreSdkConfig>(\n  config: Config,\n  hooks: Config['hooks']\n): Config => {\n  ['beforeRequest', 'afterRequest'].reduce((acc, key) => {\n    acc[key] = [].concat(config.hooks?.[key] || []).concat(hooks?.[key] || []);\n\n    return acc;\n  }, (config.hooks ??= {}));\n\n  return config;\n};\n\nexport { compose } from './compose';\n\n/**\n * Extract auth info (JWT response) from fetch response\n * We assume that the auth info is under a \"authInfo\" attribute (flow response)\n * Or the body itself (other auth methods response)\n */\nexport const getAuthInfoFromResponse = async (\n  res: Response\n): Promise<Partial<JWTResponse>> => {\n  if (!res?.ok) return {};\n  const body = await res?.clone().json();\n  return body?.authInfo || body || {};\n};\n\n/**\n * Extract user from fetch response\n * User my exist under \"user\" attribute (auth methods response)\n * Or the body itself (when calling \"me\")\n */\nexport const getUserFromResponse = async (\n  res: Response\n): Promise<UserResponse> | undefined => {\n  const authInfo = await getAuthInfoFromResponse(res);\n\n  return (\n    authInfo?.user ||\n    (authInfo?.hasOwnProperty('userId')\n      ? (authInfo as UserResponse)\n      : undefined)\n  );\n};\n\nexport const isLocalStorage = typeof localStorage !== 'undefined';\n\nexport const setLocalStorage = (key: string, value: string) =>\n  isLocalStorage && localStorage?.setItem(key, value);\nexport const getLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.getItem(key);\nexport const removeLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.removeItem(key);\n","const logger = {\n  debug: (...args: any[]) => {\n    // eslint-disable-next-line no-console\n    console.debug(...args);\n  },\n};\n\nexport default logger;\n","// This sdk can be used in SSR apps\nexport const IS_BROWSER = typeof window !== 'undefined';\n","import { IS_BROWSER } from '../../constants';\n\nconst FINGERPRINT_PUBLIC_KEY = 'fingerprint.public.key';\nconst FINGERPRINT_ENDPOINT_URL = 'fingerprint.endpoint.url';\n\n/** Fingerprint.js custom API endpoint */\nexport const FP_EP_URL =\n  (IS_BROWSER && localStorage?.getItem(FINGERPRINT_ENDPOINT_URL)) ||\n  'https://fp.descope.com';\n/** Fingerprint visitor data */\nexport const FP_BODY_DATA = 'fpData';\n/** Session ID for visitor */\nexport const VISITOR_SESSION_ID_PARAM = 'vsid';\n/** Request ID for visitor */\nexport const VISITOR_REQUEST_ID_PARAM = 'vrid';\n/** FP storage key */\nexport const FP_STORAGE_KEY = 'fp';\n// Storage FP Keys TTL is 24 hours\nexport const STORAGE_TTL_MS = 24 * 60 * 60 * 1000;\n","import { load } from '@fingerprintjs/fingerprintjs-pro';\nimport {\n  FP_EP_URL,\n  FP_STORAGE_KEY,\n  STORAGE_TTL_MS,\n  VISITOR_REQUEST_ID_PARAM,\n  VISITOR_SESSION_ID_PARAM,\n} from './constants';\nimport { FingerprintObject } from './types';\n\nconst createFingerprintObject = (\n  sessionId: string = '',\n  requestId: string = ''\n): FingerprintObject => ({\n  [VISITOR_SESSION_ID_PARAM]: sessionId,\n  [VISITOR_REQUEST_ID_PARAM]: requestId,\n});\n\n/** Generate UUID based on current time and some randomness */\nconst generateUUID = () => {\n  // return alphanumeric, sortable uuid of 27 characters\n  return (\n    Date.now().toString(36) +\n    Math.random().toString(36).substring(2) + // removing '0.' prefix\n    Math.random().toString(36).substring(2)\n  ).substring(0, 27);\n};\n\n// Set FP data to storage with expiration\n// We set the request id and session id together so they will have the same TTL\n// This implementation is based on https://www.sohamkamani.com/javascript/localstorage-with-ttl-expiry/\nconst setFPToStorage = (value: FingerprintObject) => {\n  const now = new Date();\n  // `item` is an object which contains the value\n  // as well as the time when it's supposed to expire\n  const item = {\n    value,\n    expiry: now.getTime() + STORAGE_TTL_MS,\n  };\n  localStorage.setItem(FP_STORAGE_KEY, JSON.stringify(item));\n};\n\n// Get Fingerprint from storage, will return null if not exists, of if expired\nconst getFPFromStorage = (returnExpired = false): FingerprintObject => {\n  const itemStr = localStorage.getItem(FP_STORAGE_KEY);\n  // if the item doesn't exist, return null\n  if (!itemStr) {\n    return null;\n  }\n  const item = JSON.parse(itemStr);\n  const now = new Date();\n  // compare the expiry time of the item with the current time\n  // return null if needed\n  if (now.getTime() > item.expiry && !returnExpired) {\n    return null;\n  }\n  return item.value;\n};\n\n/**\n * Ensure fingerprint ids (request id, session id) exist.\n * If not, It will generate and load them into to browser storage.\n * NOTE: Using fingerprintJS data has cost, use considerably.\n * @param fpKey FingerprintJS API key\n */\nexport const ensureFingerprintIds = async (fpKey: string) => {\n  try {\n    if (getFPFromStorage()) {\n      // FP is already in storage, no need to\n      return;\n    }\n\n    const sessionId = generateUUID();\n    const agentP = load({ apiKey: fpKey, endpoint: FP_EP_URL });\n    const agent = await agentP;\n    const { requestId } = await agent.get({ linkedId: sessionId });\n    const fpData = createFingerprintObject(sessionId, requestId);\n    setFPToStorage(fpData);\n  } catch (ex) {\n    // istanbul ignore next\n    if (global.FB_DEBUG) {\n      // eslint-disable-next-line no-console\n      console.error(ex);\n    }\n  }\n};\n\n/**\n * Get Fingerprint data (request ids) from storage, or create empty object\n * If data is expired, return it anyway\n */\nexport const getFingerprintData = (): FingerprintObject => {\n  // get from storage, fallback to default\n  return getFPFromStorage(true) || createFingerprintObject();\n};\n","import { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { BeforeRequestHook } from '../../types';\nimport { addHooks } from '../helpers';\nimport { FP_BODY_DATA } from './constants';\nimport { ensureFingerprintIds, getFingerprintData } from './helpers';\nimport { FingerprintOptions } from './types';\n\nconst beforeRequest: BeforeRequestHook = (config) => {\n  if (config.body) {\n    config.body[FP_BODY_DATA] = getFingerprintData();\n  }\n\n  return config;\n};\n\n/**\n * Add fingerprint data to outgoing requests\n */\nexport const withFingerprint =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ fpKey, fpLoad, ...config }: Parameters<T>[0] & FingerprintOptions) => {\n    // relevant only if fpKey was provided\n    if (!fpKey) {\n      return createSdk({\n        ...config,\n      });\n    }\n    if (!IS_BROWSER) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Fingerprint is a client side only capability and will not work when running in the server'\n      );\n    } else if (fpLoad) {\n      ensureFingerprintIds(fpKey).catch(() => null);\n    }\n\n    return createSdk(addHooks(config, { beforeRequest }));\n  };\n","/** Login Id of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_LOGIN_ID = 'dls_last_user_login_id';\n\n/** Display name of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_DISPLAY_NAME =\n  'dls_last_user_display_name';\n","import {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport {\n  LOCAL_STORAGE_LAST_USER_LOGIN_ID,\n  LOCAL_STORAGE_LAST_USER_DISPLAY_NAME,\n} from './constants';\n\nexport const setLastUserLoginId = (loginId: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID, loginId);\n};\n\nexport const getLastUserLoginId = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const removeLastUserLoginId = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const setLastUserDisplayName = (displayName: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME, displayName);\n};\n\nexport const getLastUserDisplayName = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n\nexport const removeLastUserDisplayName = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook, CoreSdk } from '../../types';\nimport { addHooks, getUserFromResponse } from '../helpers';\nimport {\n  getLastUserLoginId,\n  removeLastUserLoginId,\n  setLastUserLoginId,\n  getLastUserDisplayName,\n  removeLastUserDisplayName,\n  setLastUserDisplayName,\n} from './helpers';\n\n/**\n * Adds last logged in user to flow start request\n */\n// eslint-disable-next-line import/exports-last\nexport const withLastLoggedInUser =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (\n    config: Parameters<T>[0]\n  ): ReturnType<T> & {\n    getLastUserLoginId: typeof getLastUserLoginId;\n    getLastUserDisplayName: typeof getLastUserDisplayName;\n  } => {\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const userDetails = await getUserFromResponse(res);\n      const loginId = userDetails?.loginIds?.[0];\n      const displayName = userDetails?.name;\n      if (loginId) {\n        setLastUserLoginId(loginId);\n        setLastUserDisplayName(displayName);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    let wrappedSdk = wrapWith(sdk, ['flow.start'], startWrapper);\n    wrappedSdk = wrapWith(wrappedSdk, ['logout', 'logoutAll'], logoutWrapper);\n    return Object.assign(wrappedSdk, {\n      getLastUserLoginId,\n      getLastUserDisplayName,\n    }) as any;\n  };\n\nconst startWrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    args[1] = args[1] || {};\n    const [, options = {}] = args as unknown as Parameters<\n      CoreSdk['flow']['start']\n    >;\n    const loginId = getLastUserLoginId();\n    const displayName = getLastUserDisplayName();\n\n    if (loginId) {\n      options.lastAuth ??= {};\n      options.lastAuth.loginId = loginId;\n      options.lastAuth.name = displayName;\n    }\n\n    const resp = await fn(...args);\n\n    return resp;\n  };\n\nconst logoutWrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    removeLastUserLoginId();\n    removeLastUserDisplayName();\n\n    return resp;\n  };\n","// create publisher/subscriber instances\nexport function createPubSub<T extends any>() {\n  const cbs = [];\n\n  const sub = (cb: (data: T) => void) => {\n    const idx = cbs.push(cb) - 1;\n    return () => cbs.splice(idx, 1);\n  };\n\n  const pub = (data: T) => {\n    cbs.forEach((cb) => cb(data));\n  };\n\n  return { pub, sub };\n}\n","import { SdkFnWrapper, UserResponse, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk, WebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport {\n  addHooks,\n  getAuthInfoFromResponse,\n  getUserFromResponse,\n} from '../helpers';\nimport { createPubSub } from './helpers';\n\n/**\n * Adds 2 event functions to the sdk,\n * onSessionTokenChange: Gets a callback and call it whenever there is a change in session token\n * onUserChange: Gets a callback and call it whenever there is a change in current logged in user\n */\nexport const withNotifications =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) => {\n    const sessionPS = createPubSub<string | null>();\n    const userPS = createPubSub<UserResponse | null>();\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      if (res?.status === 401) {\n        sessionPS.pub(null);\n        userPS.pub(null);\n      } else {\n        const userDetails = await getUserFromResponse(res);\n        if (userDetails) userPS.pub(userDetails);\n\n        const { sessionJwt } = await getAuthInfoFromResponse(res);\n        if (sessionJwt) sessionPS.pub(sessionJwt);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n\n        sessionPS.pub(null);\n        userPS.pub(null);\n\n        return resp;\n      };\n\n    const wrappedSdk = wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n\n    return Object.assign(wrappedSdk, {\n      onSessionTokenChange: sessionPS.sub,\n      onUserChange: userPS.sub,\n    });\n  };\n","/** Default name for the session cookie name / local storage key */\nexport const SESSION_TOKEN_KEY = 'DS';\n/** Default name for the refresh local storage key */\nexport const REFRESH_TOKEN_KEY = 'DSR';\n","import { JWTResponse } from '@descope/core-js-sdk';\nimport Cookies from 'js-cookie';\nimport { BeforeRequestHook } from '../../types';\nimport { REFRESH_TOKEN_KEY, SESSION_TOKEN_KEY } from './constants';\nimport {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\n\n/**\n * Store the session JWT as a cookie on the given domain and path with the given expiration.\n * This is useful so that the application backend will automatically get the cookie for the session\n * @param name cookie name\n * @param value The JWT to store as a cookie\n * @param cookieParams configuration that is usually returned from the JWT\n */\nfunction setJwtTokenCookie(\n  name: string,\n  value: string,\n  { cookiePath, cookieDomain, cookieExpiration }: Partial<JWTResponse>\n) {\n  if (value) {\n    const expires = new Date(cookieExpiration * 1000); // we are getting response from the server in seconds instead of ms\n    Cookies.set(name, value, {\n      path: cookiePath,\n      domain: cookieDomain,\n      expires,\n      sameSite: 'Strict',\n      secure: true,\n    });\n  }\n}\n\nexport const persistTokens = (\n  { refreshJwt, sessionJwt, ...cookieParams } = {} as Partial<JWTResponse>,\n  sessionTokenViaCookie = false\n) => {\n  // persist refresh token\n  refreshJwt && setLocalStorage(REFRESH_TOKEN_KEY, refreshJwt);\n\n  // persist session token\n  if (sessionJwt) {\n    sessionTokenViaCookie\n      ? setJwtTokenCookie(SESSION_TOKEN_KEY, sessionJwt, cookieParams)\n      : setLocalStorage(SESSION_TOKEN_KEY, sessionJwt);\n  }\n};\n\n/** Return the refresh token from the localStorage. Not for production usage because refresh token will not be saved in localStorage. */\nexport function getRefreshToken() {\n  return getLocalStorage(REFRESH_TOKEN_KEY) || '';\n}\n\n/**\n * Return the session token. first try to get from cookie, and fallback to local storage\n * See sessionTokenViaCookie option for more details about session token location\n */\nexport function getSessionToken(): string {\n  return (\n    Cookies.get(SESSION_TOKEN_KEY) || getLocalStorage(SESSION_TOKEN_KEY) || ''\n  );\n}\n\n/** Remove both the localStorage refresh JWT and the session cookie */\nexport function clearTokens() {\n  removeLocalStorage(REFRESH_TOKEN_KEY);\n  removeLocalStorage(SESSION_TOKEN_KEY);\n  Cookies.remove(SESSION_TOKEN_KEY);\n}\n\nexport const beforeRequest: BeforeRequestHook = (config) =>\n  Object.assign(config, { token: config.token || getRefreshToken() });\n","/* eslint-disable import/exports-last */\nimport { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  beforeRequest,\n  clearTokens,\n  getRefreshToken,\n  getSessionToken,\n  persistTokens,\n} from './helpers';\nimport { PersistTokensOptions } from './types';\n\n/**\n * Persist authentication tokens in cookie/storage\n */\nexport const withPersistTokens =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  <A extends boolean>({\n    persistTokens: isPersistTokens,\n    sessionTokenViaCookie,\n    ...config\n  }: Parameters<T>[0] & PersistTokensOptions<A>): A extends true\n    ? ReturnType<T> & {\n        getRefreshToken: typeof getRefreshToken;\n        getSessionToken: typeof getSessionToken;\n      }\n    : ReturnType<T> => {\n    if (!isPersistTokens || !IS_BROWSER) {\n      if (isPersistTokens) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          'Storing auth tokens in local storage and cookies are a client side only capabilities and will not be done when running in the server'\n        );\n      }\n      return createSdk(config) as any;\n    }\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      if (res?.status === 401) {\n        clearTokens();\n      } else {\n        persistTokens(\n          await getAuthInfoFromResponse(res),\n          sessionTokenViaCookie\n        );\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { beforeRequest, afterRequest }));\n\n    const wrappedSdk = wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n\n    return Object.assign(wrappedSdk, {\n      getRefreshToken,\n      getSessionToken,\n    }) as any;\n  };\n\nconst wrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    clearTokens();\n\n    return resp;\n  };\n\nexport default withPersistTokens;\n","import { JWTResponse, SdkResponse, ResponseData } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../constants';\nimport { CoreSdk } from '../types';\n\ntype CreateWebauthn = typeof createWebAuthn;\n\nconst withCoreFns =\n  <I extends Parameters<CreateWebauthn>, O extends ReturnType<CreateWebauthn>>(\n    creator: (...args: I) => O\n  ) =>\n  (...args: I) => {\n    const obj = creator(...args);\n\n    Object.assign(obj.signUp, args[0].webauthn.signUp);\n    Object.assign(obj.signIn, args[0].webauthn.signIn);\n    Object.assign(obj.signUpOrIn, args[0].webauthn.signUpOrIn);\n    Object.assign(obj.update, args[0].webauthn.update);\n\n    return obj as {\n      [K in keyof O]: K extends keyof I[0]['webauthn']\n        ? O[K] & I[0]['webauthn'][K]\n        : O[K];\n    };\n  };\n\n/** Constructs a higher level WebAuthn API that wraps the functions from code-js-sdk */\nconst createWebAuthn = (sdk: CoreSdk) => ({\n  async signUp(identifier: string, name: string) {\n    const startResponse = await sdk.webauthn.signUp.start(\n      identifier,\n      window.location.origin,\n      name\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signUp.finish(\n      startResponse.data.transactionId,\n      createResponse\n    );\n    return finishResponse;\n  },\n\n  async signIn(identifier: string) {\n    const startResponse = await sdk.webauthn.signIn.start(\n      identifier,\n      window.location.origin\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const getResponse = await get(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signIn.finish(\n      startResponse.data.transactionId,\n      getResponse\n    );\n    return finishResponse;\n  },\n\n  async signUpOrIn(identifier: string) {\n    const startResponse = await sdk.webauthn.signUpOrIn.start(\n      identifier,\n      window.location.origin\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    if (startResponse.data?.create) {\n      const createResponse = await create(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signUp.finish(\n        startResponse.data.transactionId,\n        createResponse\n      );\n      return finishResponse;\n    } else {\n      const getResponse = await get(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signIn.finish(\n        startResponse.data.transactionId,\n        getResponse\n      );\n      return finishResponse;\n    }\n  },\n\n  async update(identifier: string, token: string) {\n    const startResponse = await sdk.webauthn.update.start(\n      identifier,\n      window.location.origin,\n      token\n    );\n    if (!startResponse.ok) {\n      return startResponse as SdkResponse<ResponseData>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.update.finish(\n      startResponse.data.transactionId,\n      createResponse\n    );\n    return finishResponse;\n  },\n\n  /** Helper functions for working with WebAuthn browser APIs using JSON data */\n  helpers: {\n    /** Wraps the navigation.credentials.create call to translate JSON inputs and outputs */\n    create,\n    /** Wraps the navigation.credentials.get call to translate JSON inputs and outputs */\n    get,\n    /** Checks if the browser supports WebAuthn, and can optionally require in\n     * addition that the browser supports WebAuthn with built-in biometrics */\n    isSupported,\n    conditional,\n  },\n});\n\n// Helpers functions\n\nasync function create(options: string): Promise<string> {\n  const createOptions = decodeCreateOptions(options);\n  const createResponse = (await navigator.credentials.create(\n    createOptions\n  )) as AttestationPublicKeyCredential;\n  return encodeCreateResponse(createResponse);\n}\n\nasync function get(options: string): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  const getResponse = (await navigator.credentials.get(\n    getOptions\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n/**\n * This function should be used in passkeys autofill (conditional UI)\n * It handles the call to \"navigator.credentials.get\" and adds the required options\n * @param options webauthn start options\n * @param abort: AbortController instance\n * @returns encoded \"navigator.credentials.get\" response\n */\nasync function conditional(\n  options: string,\n  abort: AbortController\n): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  getOptions.signal = abort.signal;\n  getOptions.mediation = 'conditional' as any;\n  const getResponse = (await navigator.credentials.get(\n    getOptions\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n// eslint-disable-next-line import/exports-last\nexport async function isSupported(\n  requirePlatformAuthenticator: boolean = false\n): Promise<boolean> {\n  if (!IS_BROWSER) {\n    return Promise.resolve(false);\n  }\n  const supported = !!(\n    window.PublicKeyCredential &&\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get\n  );\n  if (\n    supported &&\n    requirePlatformAuthenticator &&\n    PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable\n  ) {\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n  }\n  return supported;\n}\n\n// Conversion of data structures for Create/Attestation/Register ceremony\n\ntype AttestationPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAttestationResponse;\n};\n\nfunction decodeCreateOptions(value: string): CredentialCreationOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.user.id = decodeBase64Url(options.publicKey.user.id);\n  options.publicKey.excludeCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeCreateResponse(\n  credential: AttestationPublicKeyCredential\n): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      attestationObject: encodeBase64Url(credential.response.attestationObject),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n    },\n  });\n}\n\n// Conversion of data structures for Get/Assertion/Login ceremony\n\ntype AssertionPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAssertionResponse;\n};\n\nfunction decodeGetOptions(value: string): CredentialRequestOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.allowCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeGetResponse(credential: AssertionPublicKeyCredential): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      authenticatorData: encodeBase64Url(credential.response.authenticatorData),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n      signature: encodeBase64Url(credential.response.signature),\n      userHandle: credential.response.userHandle\n        ? encodeBase64Url(credential.response.userHandle)\n        : undefined,\n    },\n  });\n}\n\n// Conversion between ArrayBuffers and Base64Url strings\n\nfunction decodeBase64Url(value: string): ArrayBufferLike {\n  const base64 = value.replace(/_/g, '/').replace(/-/g, '+');\n  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;\n}\n\nfunction encodeBase64Url(value: ArrayBufferLike): string {\n  const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(value)));\n  return base64.replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '');\n}\n\n// Exports\nexport default withCoreFns(createWebAuthn);\n","import { CoreSdk, ReplaceParam } from '../types';\nimport { isSupported } from './webauthn';\n\ntype CoreSdkFlowStartArgs = Parameters<CoreSdk['flow']['start']>;\ntype Options = Pick<\n  CoreSdkFlowStartArgs[1],\n  'tenant' | 'redirectUrl' | 'redirectAuth' | 'oidcIdpStateId'\n> & {\n  lastAuth?: Omit<CoreSdkFlowStartArgs[1]['lastAuth'], 'loginId' | 'name'>;\n};\n\nexport default (coreSdk: CoreSdk) => ({\n  ...coreSdk.flow,\n  // wrap start fn and adds more data to the start options\n  start: async (...args: ReplaceParam<CoreSdkFlowStartArgs, '1', Options>) => {\n    const webAuthnSupport = await isSupported();\n    const decoratedOptions = {\n      redirectUrl: window.location.href, // for backward compatibility\n      location: window.location.href,\n      ...args[1],\n      deviceInfo: {\n        webAuthnSupport,\n      },\n    };\n\n    args[1] = decoratedOptions;\n\n    return coreSdk.flow.start(...args);\n  },\n});\n","import createCoreSdk from '@descope/core-js-sdk';\nimport createWebAuthn from './webauthn';\nimport withFlow from './flow';\n\nconst createSdk = (...args: Parameters<typeof createCoreSdk>) => {\n  const coreSdk = createCoreSdk(...args);\n\n  return {\n    ...coreSdk,\n    flow: withFlow(coreSdk),\n    webauthn: createWebAuthn(coreSdk),\n  };\n};\n\nexport default createSdk;\n\nexport type CreateWebSdk = typeof createSdk;\nexport type WebSdk = ReturnType<CreateWebSdk>;\n","import { compose } from './enhancers/helpers';\nimport { withAnalytics } from './enhancers/withAnalytics';\nimport { withAutoRefresh } from './enhancers/withAutoRefresh';\nimport { withFingerprint } from './enhancers/withFingerprint';\nimport { withLastLoggedInUser } from './enhancers/withLastLoggedInUser';\nimport { withNotifications } from './enhancers/withNotifications';\nimport withPersistTokens from './enhancers/withPersistTokens';\nimport createSdk from './sdk';\n\nconst decoratedCreateSdk = compose(\n  withFingerprint,\n  withAutoRefresh,\n  withAnalytics,\n  withNotifications,\n  withLastLoggedInUser, // must be one before last due to TS types\n  withPersistTokens // must be last due to TS known limitation https://github.com/microsoft/TypeScript/issues/30727\n)(createSdk);\n\nexport type { UserResponse } from './types';\n\n// Note: make sure to update packages/web-js-sdk/test/umd.test.ts when adding new constants\nexport {\n  REFRESH_TOKEN_KEY,\n  SESSION_TOKEN_KEY,\n} from './enhancers/withPersistTokens/constants';\n\nexport default decoratedCreateSdk;\n","import { CreateWebSdk, WebSdk } from '../../sdk';\n\ntype Fn = (arg: any) => any;\n\nexport function compose<Input, A1>(\n  fn1: (input: Input) => A1\n): (input: Input) => A1;\n\nexport function compose<Input, A1, A2>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2\n): (input: Input) => A2;\n\nexport function compose<Input, A1, A2, A3>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3\n): (input: Input) => A3;\n\nexport function compose<Input, A1, A2, A3, A4>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4\n): (input: Input) => A4;\n\nexport function compose<Input, A1, A2, A3, A4, A5>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5\n): (input: Input) => A5;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6\n): (input: Input) => A6;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7\n): (input: Input) => A7;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8\n): (input: Input) => A8;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9\n): (input: Input) => A9;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n  fn10: (input: A9) => A10\n): (input: Input) => A10;\n\n/**\n * Currently there is no way to create a compose function in Typescript without using overloading\n * This function currently support up to 10 wrappers\n * If needed you can add more by duplicating the type and add more parameters\n */\n\nexport function compose(...args: Fn[]) {\n  return (data: any) => args.reduce((acc, elem) => elem(acc), data) as any;\n}\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  createTimerFunctions,\n  getTokenExpiration,\n  millisecondsUntilDate,\n} from './helpers';\nimport { AutoRefreshOptions } from './types';\nimport logger from '../helpers/logger';\n\n// The amount of time (ms) to trigger the refresh before session expires\nconst REFRESH_THRESHOLD = 20 * 1000; // 20 sec\n\n/**\n * Automatically refresh the session token before it expires\n * It uses the the refresh token that is extracted from API response to do that\n */\nexport const withAutoRefresh =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ autoRefresh, ...config }: Parameters<T>[0] & AutoRefreshOptions) => {\n    if (!autoRefresh) return createSdk(config);\n\n    // if we hold a single timer id, there might be a case where we override it before canceling the timer, this might cause many calls to refresh\n    // in order to prevent it, we hold a list of timers and cancel all of them when a new timer is set, which means we should have one active timer only at a time\n    const { clearAllTimers, setTimer } = createTimerFunctions();\n\n    // we need to hold the expiration time and the refresh token in order to refresh the session\n    // when the user comes back to the tab or from background/lock screen/etc.\n    let sessionExpiration: Date;\n    let refreshToken: string;\n    document.addEventListener('visibilitychange', () => {\n      // tab becomes visible and the session is expired, do a refresh\n      if (\n        document.visibilityState === 'visible' &&\n        new Date() > sessionExpiration\n      ) {\n        logger.debug('Expiration time passed, refreshing session');\n        sdk.refresh(refreshToken);\n      }\n    });\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const { refreshJwt, sessionJwt } = await getAuthInfoFromResponse(res);\n\n      // if we got 401 we want to cancel all timers\n      if (res?.status === 401) {\n        logger.debug('Received 401, canceling all timers');\n        clearAllTimers();\n      } else if (sessionJwt) {\n        sessionExpiration = getTokenExpiration(sessionJwt);\n        refreshToken = refreshJwt;\n        const timeout =\n          millisecondsUntilDate(sessionExpiration) - REFRESH_THRESHOLD;\n        clearAllTimers();\n\n        const refreshTimeStr = new Date(\n          Date.now() + timeout\n        ).toLocaleTimeString('en-US', { hour12: false });\n        logger.debug(\n          `Setting refresh timer for ${refreshTimeStr}. (${timeout}ms)`\n        );\n\n        setTimer(() => {\n          logger.debug('Refreshing session due to timer');\n          sdk.refresh(refreshJwt);\n        }, timeout);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n        logger.debug('Clearing all timers');\n        clearAllTimers();\n\n        return resp;\n      };\n\n    return wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n  };\n","/**\n * Get the JWT expiration WITHOUT VALIDATING the JWT\n * @param token The JWT to extract expiration from\n * @returns The Date for when the JWT expires or null if there is an issue\n */\nexport const getTokenExpiration = (token: string) => {\n  const parts = token.split('.');\n  try {\n    if (parts.length === 3) {\n      const claims = JSON.parse(window.atob(parts[1]));\n      if (claims.exp) {\n        return new Date(claims.exp * 1000);\n      }\n    }\n  } catch (e) {}\n  return null;\n};\n\nexport const millisecondsUntilDate = (date: Date) =>\n  date ? date.getTime() - new Date().getTime() : 0;\n\nexport const createTimerFunctions = () => {\n  const timerIds: NodeJS.Timeout[] = [];\n\n  const clearAllTimers = () => {\n    while (timerIds.length) {\n      clearTimeout(timerIds.pop());\n    }\n  };\n\n  const setTimer = (cb: () => void, timeout: number) => {\n    timerIds.push(setTimeout(cb, timeout));\n  };\n\n  return { clearAllTimers, setTimer };\n};\n","import { CreateWebSdk } from '../sdk';\nimport { BeforeRequestHook } from '../types';\nimport { addHooks } from './helpers';\n\n// this is replaced in build time\ndeclare const BUILD_VERSION: string;\n/**\n * Adds analytics headers to requests\n */\nexport const withAnalytics =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) =>\n    createSdk({\n      ...config,\n      baseHeaders: {\n        'x-descope-sdk-name': 'web-js',\n        'x-descope-sdk-version': BUILD_VERSION,\n        ...config.baseHeaders,\n      },\n    });\n"],"names":["addHooks","config","hooks","reduce","acc","key","concat","_a","getAuthInfoFromResponse","async","res","ok","body","clone","json","authInfo","getUserFromResponse","user","hasOwnProperty","undefined","isLocalStorage","localStorage","setLocalStorage","value","setItem","getLocalStorage","getItem","removeLocalStorage","removeItem","logger","args","console","debug","IS_BROWSER","window","FP_EP_URL","createFingerprintObject","sessionId","requestId","vsid","vrid","getFPFromStorage","returnExpired","itemStr","item","JSON","parse","Date","getTime","expiry","ensureFingerprintIds","fpKey","now","toString","Math","random","substring","agentP","load","apiKey","endpoint","agent","get","linkedId","stringify","setFPToStorage","ex","global","FB_DEBUG","error","beforeRequest","LOCAL_STORAGE_LAST_USER_LOGIN_ID","LOCAL_STORAGE_LAST_USER_DISPLAY_NAME","getLastUserLoginId","getLastUserDisplayName","startWrapper","fn","options","loginId","displayName","lastAuth","name","logoutWrapper","resp","createPubSub","cbs","pub","data","forEach","cb","sub","idx","push","splice","SESSION_TOKEN_KEY","REFRESH_TOKEN_KEY","persistTokens","sessionTokenViaCookie","refreshJwt","sessionJwt","cookieParams","__rest","cookiePath","cookieDomain","cookieExpiration","expires","Cookies","set","path","domain","sameSite","secure","setJwtTokenCookie","getRefreshToken","getSessionToken","clearTokens","remove","Object","assign","token","wrapper","create","createOptions","publicKey","challenge","decodeBase64Url","id","excludeCredentials","decodeCreateOptions","createResponse","navigator","credentials","credential","rawId","encodeBase64Url","type","response","attestationObject","clientDataJSON","getOptions","decodeGetOptions","encodeGetResponse","conditional","abort","signal","mediation","isSupported","requirePlatformAuthenticator","Promise","resolve","supported","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","allowCredentials","authenticatorData","signature","userHandle","base64","replace","Uint8Array","from","atob","c","charCodeAt","buffer","btoa","String","fromCharCode","apply","creator","createWebAuthn$1","sdk","identifier","startResponse","webauthn","signUp","start","location","origin","finish","transactionId","signIn","getResponse","signUpOrIn","update","helpers","obj","withFlow","coreSdk","flow","webAuthnSupport","decoratedOptions","redirectUrl","href","deviceInfo","decoratedCreateSdk","elem","compose","createSdk","fpLoad","catch","warn","autoRefresh","clearAllTimers","setTimer","timerIds","length","clearTimeout","pop","timeout","setTimeout","createTimerFunctions","sessionExpiration","refreshToken","document","addEventListener","visibilityState","refresh","afterRequest","_req","status","parts","split","claims","exp","e","getTokenExpiration","date","refreshTimeStr","toLocaleTimeString","hour12","wrapWith","baseHeaders","sessionPS","userPS","userDetails","wrappedSdk","onSessionTokenChange","onUserChange","loginIds","setLastUserLoginId","setLastUserDisplayName","isPersistTokens","createCoreSdk","createWebAuthn"],"mappings":"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"}